{
  "id": "bp-04-design-patterns",
  "title": "Design Patterns (Entwurfsmuster)",
  "description": "Bewährte Lösungsmuster für wiederkehrende Softwaredesign-Probleme",
  "category": "BP-04",
  "subcategory": "Software-Design",
  "difficulty": "advanced",
  "examRelevance": "high",
  "newIn2025": false,
  "removedIn2025": false,
  "important": true,
  "estimatedTime": 60,
  "prerequisites": ["bp-05-encapsulation"],
  "tags": ["Design Patterns", "OOP", "Software-Design", "Gang of Four"],
  "content": "# Design Patterns (Entwurfsmuster)\n\n## Einführung\n\nDesign Patterns sind bewährte Lösungsschablonen für wiederkehrende Entwurfsprobleme in der Softwareentwicklung. Sie wurden von der \"Gang of Four\" (GoF) in ihrem Buch \"Design Patterns: Elements of Reusable Object-Oriented Software\" (1994) systematisiert.\n\n## Kategorien\n\n### 1. Creational Patterns (Erzeugungsmuster)\nBetreffen die Objekterzeugung\n\n### 2. Structural Patterns (Strukturmuster)\nBetreffen die Komposition von Klassen und Objekten\n\n### 3. Behavioral Patterns (Verhaltensmuster)\nBetreffen die Interaktion und Verantwortlichkeiten zwischen Objekten\n\n## Creational Patterns\n\n### Singleton\n\n**Problem**: Nur eine Instanz einer Klasse soll existieren.\n\n**Lösung**: Private Constructor, statische Methode für Zugriff.\n\n```java\npublic class Database {\n    private static Database instance;\n    \n    // Private Constructor\n    private Database() {\n        // Initialisierung\n    }\n    \n    // Statische Methode für Zugriff\n    public static Database getInstance() {\n        if (instance == null) {\n            instance = new Database();\n        }\n        return instance;\n    }\n    \n    public void query(String sql) {\n        // Datenbankabfrage\n    }\n}\n\n// Verwendung\nDatabase db = Database.getInstance();\ndb.query(\"SELECT * FROM users\");\n```\n\n**Anwendungsfälle:**\n- Datenbankverbindungen\n- Logger\n- Konfigurationsmanager\n\n### Factory Method\n\n**Problem**: Objekterzeugung soll flexibel sein, ohne konkrete Klassen zu kennen.\n\n**Lösung**: Interface für Objekterzeugung, Subklassen entscheiden über konkrete Klasse.\n\n```java\n// Produkt-Interface\ninterface Vehicle {\n    void drive();\n}\n\n// Konkrete Produkte\nclass Car implements Vehicle {\n    public void drive() {\n        System.out.println(\"Driving a car\");\n    }\n}\n\nclass Bike implements Vehicle {\n    public void drive() {\n        System.out.println(\"Riding a bike\");\n    }\n}\n\n// Factory\nabstract class VehicleFactory {\n    abstract Vehicle createVehicle();\n    \n    public void deliverVehicle() {\n        Vehicle vehicle = createVehicle();\n        vehicle.drive();\n    }\n}\n\nclass CarFactory extends VehicleFactory {\n    Vehicle createVehicle() {\n        return new Car();\n    }\n}\n\nclass BikeFactory extends VehicleFactory {\n    Vehicle createVehicle() {\n        return new Bike();\n    }\n}\n\n// Verwendung\nVehicleFactory factory = new CarFactory();\nfactory.deliverVehicle();\n```\n\n### Builder\n\n**Problem**: Komplexe Objekte mit vielen optionalen Parametern erstellen.\n\n**Lösung**: Schrittweise Konstruktion mit Builder-Klasse.\n\n```java\npublic class User {\n    private final String name;  // required\n    private final String email; // required\n    private final int age;      // optional\n    private final String phone; // optional\n    \n    private User(Builder builder) {\n        this.name = builder.name;\n        this.email = builder.email;\n        this.age = builder.age;\n        this.phone = builder.phone;\n    }\n    \n    public static class Builder {\n        private final String name;\n        private final String email;\n        private int age = 0;\n        private String phone = \"\";\n        \n        public Builder(String name, String email) {\n            this.name = name;\n            this.email = email;\n        }\n        \n        public Builder age(int age) {\n            this.age = age;\n            return this;\n        }\n        \n        public Builder phone(String phone) {\n            this.phone = phone;\n            return this;\n        }\n        \n        public User build() {\n            return new User(this);\n        }\n    }\n}\n\n// Verwendung\nUser user = new User.Builder(\"Max\", \"max@example.com\")\n    .age(30)\n    .phone(\"+49123456789\")\n    .build();\n```\n\n## Structural Patterns\n\n### Adapter\n\n**Problem**: Inkompatible Interfaces zusammenarbeiten lassen.\n\n**Lösung**: Adapter-Klasse übersetzt zwischen Interfaces.\n\n```java\n// Altes Interface\ninterface OldPrinter {\n    void printOld(String text);\n}\n\n// Neues Interface\ninterface NewPrinter {\n    void print(String text, boolean color);\n}\n\n// Adapter\nclass PrinterAdapter implements NewPrinter {\n    private OldPrinter oldPrinter;\n    \n    public PrinterAdapter(OldPrinter oldPrinter) {\n        this.oldPrinter = oldPrinter;\n    }\n    \n    public void print(String text, boolean color) {\n        // Ignoriere color-Parameter, alte Drucker können nur schwarz-weiß\n        oldPrinter.printOld(text);\n    }\n}\n```\n\n### Decorator\n\n**Problem**: Funktionalität dynamisch zu Objekten hinzufügen.\n\n**Lösung**: Wrapper-Klassen, die Funktionalität erweitern.\n\n```java\n// Component\ninterface Coffee {\n    double getCost();\n    String getDescription();\n}\n\n// Concrete Component\nclass SimpleCoffee implements Coffee {\n    public double getCost() {\n        return 2.0;\n    }\n    \n    public String getDescription() {\n        return \"Simple Coffee\";\n    }\n}\n\n// Decorator\nabstract class CoffeeDecorator implements Coffee {\n    protected Coffee coffee;\n    \n    public CoffeeDecorator(Coffee coffee) {\n        this.coffee = coffee;\n    }\n}\n\n// Concrete Decorators\nclass MilkDecorator extends CoffeeDecorator {\n    public MilkDecorator(Coffee coffee) {\n        super(coffee);\n    }\n    \n    public double getCost() {\n        return coffee.getCost() + 0.5;\n    }\n    \n    public String getDescription() {\n        return coffee.getDescription() + \", Milk\";\n    }\n}\n\nclass SugarDecorator extends CoffeeDecorator {\n    public SugarDecorator(Coffee coffee) {\n        super(coffee);\n    }\n    \n    public double getCost() {\n        return coffee.getCost() + 0.2;\n    }\n    \n    public String getDescription() {\n        return coffee.getDescription() + \", Sugar\";\n    }\n}\n\n// Verwendung\nCoffee coffee = new SimpleCoffee();\ncoffee = new MilkDecorator(coffee);\ncoffee = new SugarDecorator(coffee);\nSystem.out.println(coffee.getDescription() + \" costs \" + coffee.getCost());\n// Output: Simple Coffee, Milk, Sugar costs 2.7\n```\n\n### Facade\n\n**Problem**: Komplexes Subsystem vereinfachen.\n\n**Lösung**: Einheitliche Schnittstelle für Subsystem.\n\n```java\n// Komplexe Subsysteme\nclass CPU {\n    public void freeze() { System.out.println(\"CPU freeze\"); }\n    public void jump(long position) { System.out.println(\"CPU jump\"); }\n    public void execute() { System.out.println(\"CPU execute\"); }\n}\n\nclass Memory {\n    public void load(long position, byte[] data) {\n        System.out.println(\"Memory load\");\n    }\n}\n\nclass HardDrive {\n    public byte[] read(long lba, int size) {\n        System.out.println(\"HardDrive read\");\n        return new byte[size];\n    }\n}\n\n// Facade\nclass ComputerFacade {\n    private CPU cpu;\n    private Memory memory;\n    private HardDrive hardDrive;\n    \n    public ComputerFacade() {\n        this.cpu = new CPU();\n        this.memory = new Memory();\n        this.hardDrive = new HardDrive();\n    }\n    \n    public void start() {\n        cpu.freeze();\n        memory.load(0, hardDrive.read(0, 1024));\n        cpu.jump(0);\n        cpu.execute();\n    }\n}\n\n// Verwendung\nComputerFacade computer = new ComputerFacade();\ncomputer.start(); // Einfacher Aufruf statt komplexer Subsystem-Interaktion\n```\n\n## Behavioral Patterns\n\n### Observer\n\n**Problem**: Objekte sollen über Änderungen informiert werden.\n\n**Lösung**: Subject benachrichtigt Observer bei Änderungen.\n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n\n// Observer Interface\ninterface Observer {\n    void update(String message);\n}\n\n// Subject\nclass NewsAgency {\n    private List<Observer> observers = new ArrayList<>();\n    private String news;\n    \n    public void addObserver(Observer observer) {\n        observers.add(observer);\n    }\n    \n    public void removeObserver(Observer observer) {\n        observers.remove(observer);\n    }\n    \n    public void setNews(String news) {\n        this.news = news;\n        notifyObservers();\n    }\n    \n    private void notifyObservers() {\n        for (Observer observer : observers) {\n            observer.update(news);\n        }\n    }\n}\n\n// Concrete Observer\nclass NewsChannel implements Observer {\n    private String name;\n    \n    public NewsChannel(String name) {\n        this.name = name;\n    }\n    \n    public void update(String news) {\n        System.out.println(name + \" received news: \" + news);\n    }\n}\n\n// Verwendung\nNewsAgency agency = new NewsAgency();\nNewsChannel channel1 = new NewsChannel(\"Channel 1\");\nNewsChannel channel2 = new NewsChannel(\"Channel 2\");\n\nagency.addObserver(channel1);\nagency.addObserver(channel2);\n\nagency.setNews(\"Breaking News!\");\n// Output:\n// Channel 1 received news: Breaking News!\n// Channel 2 received news: Breaking News!\n```\n\n### Strategy\n\n**Problem**: Algorithmen austauschbar machen.\n\n**Lösung**: Algorithmen in separate Klassen kapseln.\n\n```java\n// Strategy Interface\ninterface PaymentStrategy {\n    void pay(double amount);\n}\n\n// Concrete Strategies\nclass CreditCardPayment implements PaymentStrategy {\n    private String cardNumber;\n    \n    public CreditCardPayment(String cardNumber) {\n        this.cardNumber = cardNumber;\n    }\n    \n    public void pay(double amount) {\n        System.out.println(\"Paid \" + amount + \" with credit card \" + cardNumber);\n    }\n}\n\nclass PayPalPayment implements PaymentStrategy {\n    private String email;\n    \n    public PayPalPayment(String email) {\n        this.email = email;\n    }\n    \n    public void pay(double amount) {\n        System.out.println(\"Paid \" + amount + \" with PayPal \" + email);\n    }\n}\n\n// Context\nclass ShoppingCart {\n    private PaymentStrategy paymentStrategy;\n    \n    public void setPaymentStrategy(PaymentStrategy strategy) {\n        this.paymentStrategy = strategy;\n    }\n    \n    public void checkout(double amount) {\n        paymentStrategy.pay(amount);\n    }\n}\n\n// Verwendung\nShoppingCart cart = new ShoppingCart();\ncart.setPaymentStrategy(new CreditCardPayment(\"1234-5678-9012-3456\"));\ncart.checkout(100.0);\n\ncart.setPaymentStrategy(new PayPalPayment(\"user@example.com\"));\ncart.checkout(50.0);\n```\n\n### Template Method\n\n**Problem**: Algorithmus-Struktur definieren, Details in Subklassen.\n\n**Lösung**: Abstrakte Klasse mit Template-Methode.\n\n```java\nabstract class DataProcessor {\n    // Template Method\n    public final void process() {\n        readData();\n        processData();\n        writeData();\n    }\n    \n    abstract void readData();\n    abstract void processData();\n    abstract void writeData();\n}\n\nclass CSVProcessor extends DataProcessor {\n    void readData() {\n        System.out.println(\"Reading CSV data\");\n    }\n    \n    void processData() {\n        System.out.println(\"Processing CSV data\");\n    }\n    \n    void writeData() {\n        System.out.println(\"Writing CSV data\");\n    }\n}\n\nclass JSONProcessor extends DataProcessor {\n    void readData() {\n        System.out.println(\"Reading JSON data\");\n    }\n    \n    void processData() {\n        System.out.println(\"Processing JSON data\");\n    }\n    \n    void writeData() {\n        System.out.println(\"Writing JSON data\");\n    }\n}\n```\n\n## Prüfungsrelevante Aspekte\n\n- Wichtigste Design Patterns kennen\n- Kategorien (Creational, Structural, Behavioral) unterscheiden\n- Probleme und Lösungen zuordnen\n- Anwendungsfälle erkennen\n- UML-Diagramme interpretieren\n- Code-Beispiele verstehen",
  "codeExamples": [
    {
      "language": "java",
      "code": "// Kombination mehrerer Patterns\n\n// Singleton + Factory\npublic class VehicleFactory {\n    private static VehicleFactory instance;\n    \n    private VehicleFactory() {}\n    \n    public static VehicleFactory getInstance() {\n        if (instance == null) {\n            instance = new VehicleFactory();\n        }\n        return instance;\n    }\n    \n    public Vehicle createVehicle(String type) {\n        switch (type) {\n            case \"car\": return new Car();\n            case \"bike\": return new Bike();\n            default: throw new IllegalArgumentException(\"Unknown type\");\n        }\n    }\n}\n\n// Strategy + Observer\nclass PriceCalculator {\n    private List<Observer> observers = new ArrayList<>();\n    private PricingStrategy strategy;\n    \n    public void setStrategy(PricingStrategy strategy) {\n        this.strategy = strategy;\n        notifyObservers(\"Strategy changed\");\n    }\n    \n    public double calculatePrice(double basePrice) {\n        return strategy.calculate(basePrice);\n    }\n    \n    public void addObserver(Observer observer) {\n        observers.add(observer);\n    }\n    \n    private void notifyObservers(String message) {\n        for (Observer obs : observers) {\n            obs.update(message);\n        }\n    }\n}",
      "explanation": "Kombination mehrerer Design Patterns in der Praxis",
      "title": "Pattern-Kombination"
    }
  ],
  "relatedQuizzes": [],
  "resources": [
    {
      "title": "Design Patterns: Elements of Reusable Object-Oriented Software",
      "url": "https://en.wikipedia.org/wiki/Design_Patterns",
      "type": "article"
    },
    {
      "title": "Refactoring Guru - Design Patterns",
      "url": "https://refactoring.guru/design-patterns",
      "type": "article"
    }
  ],
  "lastUpdated": "2025-01-10T00:00:00Z",
  "version": "1.0"
}
