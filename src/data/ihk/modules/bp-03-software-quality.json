{
  "id": "bp-03-software-quality",
  "title": "Softwarequalitätsmerkmale (ISO 25010)",
  "description": "Qualitätsmerkmale für Software nach ISO/IEC 25010 Standard (Neu ab 2025)",
  "category": "BP-03",
  "subcategory": "Softwarequalität",
  "difficulty": "intermediate",
  "examRelevance": "high",
  "newIn2025": true,
  "removedIn2025": false,
  "important": true,
  "estimatedTime": 50,
  "prerequisites": [],
  "tags": [
    "Qualität",
    "ISO 25010",
    "Software Engineering",
    "Neu 2025"
  ],
  "content": "# Softwarequalitätsmerkmale (ISO 25010)\n\n## Einführung\n\nISO/IEC 25010 (früher ISO 9126) definiert ein Qualitätsmodell für Software-Produkte. Es beschreibt acht Hauptmerkmale, die die Qualität von Software bestimmen.\n\n**Neu ab 2025**: Softwarequalitätsmerkmale nach ISO 25010 sind explizit im neuen Prüfungskatalog aufgeführt.\n\n## Die 8 Qualitätsmerkmale\n\n### 1. Functional Suitability (Funktionale Eignung)\n\n**Definition**: Grad, in dem ein Produkt Funktionen bereitstellt, die festgelegte und implizierte Anforderungen erfüllen.\n\n**Untermerkmale:**\n\n**Functional Completeness (Vollständigkeit):**\n- Alle erforderlichen Funktionen vorhanden\n- Beispiel: E-Commerce-System mit Warenkorb, Bezahlung, Bestellverfolgung\n\n**Functional Correctness (Korrektheit):**\n- Funktionen liefern korrekte Ergebnisse\n- Beispiel: Taschenrechner berechnet 2+2=4, nicht 5\n\n**Functional Appropriateness (Angemessenheit):**\n- Funktionen sind für Aufgaben geeignet\n- Beispiel: Drag-and-Drop für Datei-Upload statt komplexer Dialog\n\n### 2. Performance Efficiency (Leistungseffizienz)\n\n**Definition**: Leistung in Relation zu den eingesetzten Ressourcen.\n\n**Untermerkmale:**\n\n**Time Behaviour (Zeitverhalten):**\n- Antwortzeiten, Durchsatz\n- Beispiel: Webseite lädt in < 2 Sekunden\n\n**Resource Utilization (Ressourcennutzung):**\n- CPU, RAM, Speicher, Netzwerk\n- Beispiel: App nutzt < 100 MB RAM\n\n**Capacity (Kapazität):**\n- Maximale Anzahl gleichzeitiger Benutzer\n- Beispiel: System unterstützt 10.000 gleichzeitige Nutzer\n\n**Beispiel:**\n```python\nimport time\n\n# Schlechte Performance\ndef slow_search(items, target):\n    for item in items:\n        time.sleep(0.001)  # Simuliert langsame Operation\n        if item == target:\n            return True\n    return False\n\n# Gute Performance\ndef fast_search(items, target):\n    return target in set(items)  # O(1) statt O(n)\n```\n\n### 3. Compatibility (Kompatibilität)\n\n**Definition**: Grad, in dem ein Produkt mit anderen Produkten Informationen austauschen und/oder Funktionen nutzen kann.\n\n**Untermerkmale:**\n\n**Co-existence (Koexistenz):**\n- Funktioniert mit anderer Software auf gleichem System\n- Beispiel: App läuft parallel zu anderen Apps ohne Konflikte\n\n**Interoperability (Interoperabilität):**\n- Datenaustausch mit anderen Systemen\n- Beispiel: Export/Import von Daten in Standardformaten (JSON, XML)\n\n**Beispiel:**\n```python\n# Interoperabilität durch Standard-APIs\nimport json\n\ndef export_data(users):\n    \"\"\"Exportiert Daten in Standard-JSON-Format\"\"\"\n    return json.dumps(users, indent=2)\n\ndef import_data(json_string):\n    \"\"\"Importiert Daten aus Standard-JSON-Format\"\"\"\n    return json.loads(json_string)\n```\n\n### 4. Usability (Benutzerfreundlichkeit)\n\n**Definition**: Grad, in dem ein Produkt von bestimmten Benutzern effektiv, effizient und zufriedenstellend genutzt werden kann.\n\n**Untermerkmale:**\n\n**Appropriateness Recognizability (Erkennbarkeit):**\n- Benutzer erkennen, ob Software für ihre Bedürfnisse geeignet ist\n- Beispiel: Klare Beschreibung der Funktionen\n\n**Learnability (Erlernbarkeit):**\n- Wie schnell können Benutzer die Software lernen?\n- Beispiel: Intuitive Benutzeroberfläche, Tutorials\n\n**Operability (Bedienbarkeit):**\n- Einfache Bedienung und Kontrolle\n- Beispiel: Klare Navigation, konsistente UI\n\n**User Error Protection (Fehlerschutz):**\n- Schutz vor Bedienfehlern\n- Beispiel: Bestätigungsdialog vor Löschen\n\n**User Interface Aesthetics (Ästhetik):**\n- Ansprechendes Design\n- Beispiel: Modernes, konsistentes Design\n\n**Accessibility (Barrierefreiheit):**\n- Nutzbar für Menschen mit Einschränkungen\n- Beispiel: Screen-Reader-Unterstützung, Tastaturnavigation\n\n### 5. Reliability (Zuverlässigkeit)\n\n**Definition**: Grad, in dem ein System unter festgelegten Bedingungen zuverlässig funktioniert.\n\n**Untermerkmale:**\n\n**Maturity (Reife):**\n- Geringe Fehlerrate im Normalbetrieb\n- Beispiel: Stabile Software ohne häufige Abstürze\n\n**Availability (Verfügbarkeit):**\n- System ist verfügbar, wenn benötigt\n- Beispiel: 99.9% Uptime (43 Min. Ausfall/Monat)\n\n**Fault Tolerance (Fehlertoleranz):**\n- System funktioniert trotz Fehlern\n- Beispiel: Graceful Degradation bei Datenbankausfall\n\n**Recoverability (Wiederherstellbarkeit):**\n- Schnelle Wiederherstellung nach Ausfall\n- Beispiel: Automatisches Backup und Recovery\n\n**Beispiel:**\n```python\nimport logging\n\ndef fetch_user_data(user_id):\n    \"\"\"Fehlertolerante Funktion mit Fallback\"\"\"\n    try:\n        # Primäre Datenquelle\n        return database.get_user(user_id)\n    except DatabaseError:\n        logging.warning(\"Database unavailable, using cache\")\n        # Fallback auf Cache\n        return cache.get_user(user_id)\n    except Exception as e:\n        logging.error(f\"Error fetching user: {e}\")\n        # Graceful Degradation\n        return {\"id\": user_id, \"name\": \"Unknown\"}\n```\n\n### 6. Security (Sicherheit)\n\n**Definition**: Grad, in dem ein Produkt Informationen und Daten schützt.\n\n**Untermerkmale:**\n\n**Confidentiality (Vertraulichkeit):**\n- Nur autorisierte Zugriffe\n- Beispiel: Verschlüsselung sensibler Daten\n\n**Integrity (Integrität):**\n- Daten können nicht unbefugt geändert werden\n- Beispiel: Checksums, digitale Signaturen\n\n**Non-repudiation (Nicht-Abstreitbarkeit):**\n- Aktionen können nachgewiesen werden\n- Beispiel: Audit-Logs, digitale Signaturen\n\n**Accountability (Verantwortlichkeit):**\n- Aktionen können Entitäten zugeordnet werden\n- Beispiel: Benutzer-Logs, Authentifizierung\n\n**Authenticity (Authentizität):**\n- Identität kann nachgewiesen werden\n- Beispiel: Multi-Factor Authentication\n\n**Beispiel:**\n```python\nimport hashlib\nimport secrets\n\ndef hash_password(password):\n    \"\"\"Sicheres Password-Hashing\"\"\"\n    salt = secrets.token_hex(16)\n    pwd_hash = hashlib.pbkdf2_hmac(\n        'sha256',\n        password.encode('utf-8'),\n        salt.encode('utf-8'),\n        100000\n    )\n    return f\"{salt}${pwd_hash.hex()}\"\n\ndef verify_password(password, stored_hash):\n    \"\"\"Passwort-Verifikation\"\"\"\n    salt, pwd_hash = stored_hash.split('$')\n    new_hash = hashlib.pbkdf2_hmac(\n        'sha256',\n        password.encode('utf-8'),\n        salt.encode('utf-8'),\n        100000\n    )\n    return new_hash.hex() == pwd_hash\n```\n\n### 7. Maintainability (Wartbarkeit)\n\n**Definition**: Grad, in dem ein Produkt effektiv und effizient modifiziert werden kann.\n\n**Untermerkmale:**\n\n**Modularity (Modularität):**\n- System aus unabhängigen Komponenten\n- Beispiel: Microservices, Module\n\n**Reusability (Wiederverwendbarkeit):**\n- Komponenten können wiederverwendet werden\n- Beispiel: Bibliotheken, Frameworks\n\n**Analysability (Analysierbarkeit):**\n- Fehlerursachen können identifiziert werden\n- Beispiel: Logging, Debugging-Tools\n\n**Modifiability (Modifizierbarkeit):**\n- Änderungen können einfach durchgeführt werden\n- Beispiel: Klare Architektur, geringe Kopplung\n\n**Testability (Testbarkeit):**\n- Tests können einfach durchgeführt werden\n- Beispiel: Unit-Tests, Mocking\n\n**Beispiel:**\n```python\n# Gute Wartbarkeit durch Modularität\nclass UserService:\n    \"\"\"Klar definierte Verantwortlichkeit\"\"\"\n    \n    def __init__(self, repository, validator):\n        self.repository = repository\n        self.validator = validator\n    \n    def create_user(self, user_data):\n        # Validierung (wiederverwendbar)\n        if not self.validator.validate(user_data):\n            raise ValueError(\"Invalid user data\")\n        \n        # Speicherung (austauschbar)\n        return self.repository.save(user_data)\n```\n\n### 8. Portability (Übertragbarkeit)\n\n**Definition**: Grad, in dem ein System von einer Umgebung in eine andere übertragen werden kann.\n\n**Untermerkmale:**\n\n**Adaptability (Anpassbarkeit):**\n- Anpassung an verschiedene Umgebungen\n- Beispiel: Konfigurierbare Einstellungen\n\n**Installability (Installierbarkeit):**\n- Einfache Installation\n- Beispiel: One-Click-Installation, Docker\n\n**Replaceability (Austauschbarkeit):**\n- Kann andere Software ersetzen\n- Beispiel: Kompatible APIs, Datenformate\n\n**Beispiel:**\n```python\n# Portabilität durch Konfiguration\nimport os\n\nclass DatabaseConfig:\n    \"\"\"Anpassbar an verschiedene Umgebungen\"\"\"\n    \n    def __init__(self):\n        self.host = os.getenv('DB_HOST', 'localhost')\n        self.port = int(os.getenv('DB_PORT', '5432'))\n        self.database = os.getenv('DB_NAME', 'myapp')\n        self.user = os.getenv('DB_USER', 'admin')\n        self.password = os.getenv('DB_PASSWORD', '')\n```\n\n## Qualitätssicherung\n\n### Maßnahmen\n\n**Code Reviews:**\n- Peer-Reviews\n- Pull Requests\n\n**Testing:**\n- Unit Tests\n- Integration Tests\n- Performance Tests\n- Security Tests\n\n**Monitoring:**\n- Performance-Monitoring\n- Error-Tracking\n- User Analytics\n\n**Documentation:**\n- Code-Dokumentation\n- API-Dokumentation\n- Benutzerhandbücher\n\n## Prüfungsrelevante Aspekte\n\n- 8 Qualitätsmerkmale nach ISO 25010 kennen\n- Untermerkmale zuordnen\n- Beispiele für jedes Merkmal nennen\n- Qualitätsmaßnahmen verstehen\n- Trade-offs zwischen Merkmalen erkennen\n- Qualitätsmerkmale in Anforderungen umsetzen",
  "codeExamples": [
    {
      "language": "python",
      "code": "# Beispiel: Mehrere Qualitätsmerkmale kombiniert\n\nclass PaymentService:\n    \"\"\"Zahlungsservice mit hoher Qualität\"\"\"\n    \n    def __init__(self, logger, metrics):\n        self.logger = logger  # Maintainability: Analysierbarkeit\n        self.metrics = metrics  # Performance: Monitoring\n    \n    def process_payment(self, amount, user_id):\n        \"\"\"\n        Verarbeitet Zahlung mit Fokus auf:\n        - Reliability: Fehlertoleranz\n        - Security: Logging für Accountability\n        - Performance: Timeout\n        \"\"\"\n        start_time = time.time()\n        \n        try:\n            # Security: Validierung\n            if amount <= 0:\n                raise ValueError(\"Amount must be positive\")\n            \n            # Functional Suitability: Korrekte Verarbeitung\n            result = self._charge_payment(amount, user_id)\n            \n            # Security: Audit-Log\n            self.logger.info(f\"Payment processed: {user_id}, {amount}\")\n            \n            # Performance: Metrik\n            duration = time.time() - start_time\n            self.metrics.record('payment_duration', duration)\n            \n            return result\n            \n        except Exception as e:\n            # Reliability: Fehlerbehandlung\n            self.logger.error(f\"Payment failed: {e}\")\n            # Usability: Benutzerfreundliche Fehlermeldung\n            raise PaymentError(\"Zahlung konnte nicht verarbeitet werden\")\n    \n    def _charge_payment(self, amount, user_id):\n        # Implementierung...\n        pass",
      "explanation": "Beispiel für Code, der mehrere Qualitätsmerkmale berücksichtigt",
      "title": "Qualitätsmerkmale in der Praxis"
    }
  ],
  "relatedQuizzes": [],
  "resources": [
    {
      "title": "ISO/IEC 25010:2011",
      "url": "https://www.iso.org/standard/35733.html",
      "type": "documentation"
    }
  ],
  "lastUpdated": "2025-01-10T00:00:00Z",
  "version": "1.0",
  "learningObjectives": [
    "Understand Qualität",
    "Understand ISO 25010",
    "Understand Software Engineering",
    "Understand Neu 2025"
  ]
}
