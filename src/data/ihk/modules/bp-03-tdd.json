{
  "id": "bp-03-tdd",
  "title": "Test Driven Development (TDD)",
  "description": "Lerne das TDD-Konzept, den Red-Green-Refactor Zyklus und wie du qualitativ hochwertigen Code durch testgetriebene Entwicklung schreibst.",
  "category": "BP-03",
  "subcategory": "Entwickeln von Softwareanwendungen",
  "difficulty": "intermediate",
  "examRelevance": "high",
  "newIn2025": true,
  "removedIn2025": false,
  "important": true,
  "estimatedTime": 45,
  "prerequisites": [],
  "tags": [
    "TDD",
    "Testing",
    "Unit Tests",
    "Red-Green-Refactor",
    "Softwarequalit√§t",
    "Neu 2025"
  ],
  "content": "# Test Driven Development (TDD)\n\n## Was ist Test Driven Development?\n\nTest Driven Development (TDD) ist eine Softwareentwicklungsmethode, bei der **Tests vor dem eigentlichen Code** geschrieben werden. Dieser Ansatz f√ºhrt zu besser strukturiertem, wartbarem und fehlerfreiem Code.\n\n### Kernprinzipien von TDD\n\n1. **Test First**: Schreibe zuerst einen Test f√ºr die gew√ºnschte Funktionalit√§t\n2. **Minimal Implementation**: Implementiere nur so viel Code, wie n√∂tig ist, um den Test zu bestehen\n3. **Refactoring**: Verbessere den Code, w√§hrend alle Tests weiterhin bestehen\n\n## Der Red-Green-Refactor Zyklus\n\nTDD folgt einem iterativen Zyklus mit drei Phasen:\n\n### üî¥ Red (Rot) - Test schreiben, der fehlschl√§gt\n\n- Schreibe einen Test f√ºr eine neue Funktionalit√§t\n- Der Test schl√§gt fehl, weil die Funktionalit√§t noch nicht existiert\n- Dies best√§tigt, dass der Test tats√§chlich etwas pr√ºft\n\n### üü¢ Green (Gr√ºn) - Minimalen Code schreiben\n\n- Implementiere gerade genug Code, um den Test zu bestehen\n- Fokus liegt auf Funktionalit√§t, nicht auf Perfektion\n- Der Test sollte nun erfolgreich durchlaufen\n\n### üîµ Refactor (Refaktorieren) - Code verbessern\n\n- Verbessere die Code-Qualit√§t ohne das Verhalten zu √§ndern\n- Entferne Duplikate und optimiere die Struktur\n- Alle Tests m√ºssen weiterhin bestehen\n\n**Dann beginnt der Zyklus von vorne f√ºr die n√§chste Funktionalit√§t!**\n\n## Vorteile von TDD\n\n‚úÖ **Bessere Code-Qualit√§t**: Code ist testbar und modular aufgebaut\n\n‚úÖ **Weniger Bugs**: Fehler werden fr√ºh erkannt und behoben\n\n‚úÖ **Lebende Dokumentation**: Tests dokumentieren das erwartete Verhalten\n\n‚úÖ **Refactoring-Sicherheit**: √Ñnderungen k√∂nnen sicher durchgef√ºhrt werden\n\n‚úÖ **Klares Design**: Zwingt zu durchdachtem API-Design\n\n## Nachteile von TDD\n\n‚ùå **Zeitaufwand**: Initial mehr Zeit f√ºr Test-Erstellung\n\n‚ùå **Lernkurve**: Erfordert Umdenken und √úbung\n\n‚ùå **Overhead**: Nicht f√ºr alle Projekte gleich sinnvoll\n\n## TDD in der Praxis\n\n### Wann sollte TDD eingesetzt werden?\n\n- Bei komplexer Business-Logik\n- Bei kritischen Systemkomponenten\n- Bei langlebigen Projekten\n- Wenn hohe Code-Qualit√§t gefordert ist\n\n### Wann ist TDD weniger geeignet?\n\n- Bei Prototypen und Proof-of-Concepts\n- Bei UI-Design und Experimenten\n- Bei sehr einfachen CRUD-Operationen\n\n## Best Practices\n\n1. **Kleine Schritte**: Schreibe kleine, fokussierte Tests\n2. **Ein Test, eine Assertion**: Halte Tests einfach und klar\n3. **Aussagekr√§ftige Namen**: Test-Namen sollten das Verhalten beschreiben\n4. **Unabh√§ngige Tests**: Tests sollten isoliert und in beliebiger Reihenfolge laufen\n5. **Schnelle Tests**: Tests sollten schnell ausf√ºhrbar sein\n\n## √úbungsaufgaben\n\n### Aufgabe 1: TDD-Zyklus verstehen\n\nOrdne die folgenden Schritte dem richtigen TDD-Zyklus zu:\n- Code optimieren und Duplikate entfernen\n- Test schreiben, der fehlschl√§gt\n- Minimalen Code implementieren, um Test zu bestehen\n\n### Aufgabe 2: TDD anwenden\n\nImplementiere eine `Calculator`-Klasse mit TDD:\n1. Schreibe einen Test f√ºr Addition\n2. Implementiere die Addition\n3. Refaktoriere wenn n√∂tig\n4. Wiederhole f√ºr Subtraktion\n\n### Aufgabe 3: Vorteile erkennen\n\nNenne drei konkrete Vorteile, die TDD f√ºr die Wartbarkeit von Software bietet.\n\n## Zusammenfassung\n\nTDD ist eine bew√§hrte Methode zur Entwicklung qualitativ hochwertiger Software. Der Red-Green-Refactor Zyklus stellt sicher, dass Code testbar, wartbar und fehlerfrei ist. Obwohl TDD initial mehr Zeit erfordert, zahlt sich die Investition durch weniger Bugs und bessere Wartbarkeit aus.",
  "codeExamples": [
    {
      "language": "java",
      "title": "TDD Beispiel: Calculator-Klasse (Java mit JUnit)",
      "code": "// 1. RED: Test schreiben (schl√§gt fehl)\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass CalculatorTest {\n    @Test\n    void testAddition() {\n        Calculator calc = new Calculator();\n        int result = calc.add(2, 3);\n        assertEquals(5, result, \"2 + 3 sollte 5 ergeben\");\n    }\n}\n\n// 2. GREEN: Minimale Implementierung\nclass Calculator {\n    public int add(int a, int b) {\n        return a + b;\n    }\n}\n\n// 3. REFACTOR: Code ist bereits sauber, kein Refactoring n√∂tig\n\n// N√§chster Zyklus: Subtraktion\n@Test\nvoid testSubtraction() {\n    Calculator calc = new Calculator();\n    int result = calc.subtract(5, 3);\n    assertEquals(2, result, \"5 - 3 sollte 2 ergeben\");\n}\n\n// Implementierung\npublic int subtract(int a, int b) {\n    return a - b;\n}",
      "explanation": "Dieses Beispiel zeigt den kompletten TDD-Zyklus: Zuerst wird ein Test geschrieben, der fehlschl√§gt (RED), dann wird die minimale Implementierung hinzugef√ºgt (GREEN), und schlie√ülich wird der Code bei Bedarf refaktoriert (REFACTOR)."
    },
    {
      "language": "python",
      "title": "TDD Beispiel: String-Validator (Python mit pytest)",
      "code": "# 1. RED: Test schreiben\nimport pytest\n\ndef test_email_validator_valid_email():\n    validator = EmailValidator()\n    assert validator.is_valid(\"test@example.com\") == True\n\ndef test_email_validator_invalid_email():\n    validator = EmailValidator()\n    assert validator.is_valid(\"invalid-email\") == False\n\n# 2. GREEN: Minimale Implementierung\nimport re\n\nclass EmailValidator:\n    def is_valid(self, email):\n        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n        return bool(re.match(pattern, email))\n\n# 3. REFACTOR: Regex-Pattern als Konstante auslagern\nclass EmailValidator:\n    EMAIL_PATTERN = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    \n    def is_valid(self, email):\n        if not email or not isinstance(email, str):\n            return False\n        return bool(re.match(self.EMAIL_PATTERN, email))",
      "explanation": "Dieses Python-Beispiel demonstriert TDD mit pytest. Nach der minimalen Implementierung wird der Code refaktoriert, um die Regex als Konstante zu definieren und zus√§tzliche Validierung hinzuzuf√ºgen."
    },
    {
      "language": "java",
      "title": "TDD Beispiel: BankAccount mit Gesch√§ftslogik",
      "code": "// RED: Test f√ºr Kontostand-Abfrage\n@Test\nvoid testInitialBalance() {\n    BankAccount account = new BankAccount(100.0);\n    assertEquals(100.0, account.getBalance());\n}\n\n// GREEN: Implementierung\nclass BankAccount {\n    private double balance;\n    \n    public BankAccount(double initialBalance) {\n        this.balance = initialBalance;\n    }\n    \n    public double getBalance() {\n        return balance;\n    }\n}\n\n// RED: Test f√ºr Einzahlung\n@Test\nvoid testDeposit() {\n    BankAccount account = new BankAccount(100.0);\n    account.deposit(50.0);\n    assertEquals(150.0, account.getBalance());\n}\n\n// GREEN: Implementierung\npublic void deposit(double amount) {\n    balance += amount;\n}\n\n// RED: Test f√ºr ung√ºltige Einzahlung\n@Test\nvoid testDepositNegativeAmount() {\n    BankAccount account = new BankAccount(100.0);\n    assertThrows(IllegalArgumentException.class, () -> {\n        account.deposit(-50.0);\n    });\n}\n\n// REFACTOR: Validierung hinzuf√ºgen\npublic void deposit(double amount) {\n    if (amount <= 0) {\n        throw new IllegalArgumentException(\"Betrag muss positiv sein\");\n    }\n    balance += amount;\n}",
      "explanation": "Dieses erweiterte Beispiel zeigt, wie TDD bei komplexerer Gesch√§ftslogik angewendet wird. Jede neue Anforderung (Einzahlung, Validierung) wird durch einen Test definiert, bevor der Code implementiert wird."
    }
  ],
  "relatedQuizzes": ["tdd-quiz-2025"],
  "resources": [
    {
      "title": "Test Driven Development by Example (Kent Beck)",
      "url": "https://www.oreilly.com/library/view/test-driven-development/0321146530/",
      "type": "article"
    },
    {
      "title": "JUnit 5 Dokumentation",
      "url": "https://junit.org/junit5/docs/current/user-guide/",
      "type": "documentation"
    },
    {
      "title": "pytest Dokumentation",
      "url": "https://docs.pytest.org/",
      "type": "documentation"
    }
  ],
  "lastUpdated": "2025-01-10T00:00:00Z",
  "version": "1.0"
}
