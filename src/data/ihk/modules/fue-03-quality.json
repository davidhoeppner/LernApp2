{
  "id": "fue-03-quality",
  "title": "FÜ-03: Durchführen von qualitätssichernden Maßnahmen",
  "description": "Software-Tests (Black Box, White Box, Review, Extremwertetest) und Last-/Performancetests. Qualitätssicherung ist essentiell für erfolgreiche Softwareprojekte.",
  "category": "FÜ-03",
  "subcategory": "Qualitätssichernde Maßnahmen",
  "difficulty": "intermediate",
  "examRelevance": "high",
  "newIn2025": false,
  "removedIn2025": false,
  "important": true,
  "estimatedTime": 100,
  "prerequisites": [],
  "tags": [
    "Software-Tests",
    "Black Box",
    "White Box",
    "Review",
    "Extremwertetest",
    "Last-Tests",
    "Performance-Tests",
    "Qualitätssicherung"
  ],
  "content": "# FÜ-03: Durchführen von qualitätssichernden Maßnahmen\n\n## Einführung\n\nQualitätssicherung (Quality Assurance, QA) ist ein wesentlicher Bestandteil der Softwareentwicklung. Sie stellt sicher, dass Software die Anforderungen erfüllt, fehlerfrei funktioniert und wartbar ist. **NEU AB 2025**: Last- und Performancetests sind explizit im Prüfungskatalog aufgeführt.\n\n## 1. Software-Tests\n\n### 1.1 Testziele\n\n- **Fehler finden**: Defekte und Bugs identifizieren\n- **Qualität sichern**: Anforderungen werden erfüllt\n- **Vertrauen schaffen**: Software funktioniert wie erwartet\n- **Risiken minimieren**: Fehler vor Produktivbetrieb finden\n- **Dokumentation**: Nachweis der Funktionalität\n\n### 1.2 Testprinzipien\n\n1. **Testen zeigt Anwesenheit von Fehlern**: Tests können Fehler finden, aber nicht deren Abwesenheit beweisen\n2. **Vollständiges Testen ist unmöglich**: Man kann nicht alle möglichen Eingaben testen\n3. **Frühes Testen**: Je früher Fehler gefunden werden, desto günstiger ist die Behebung\n4. **Fehler-Clustering**: 80% der Fehler finden sich in 20% der Module\n5. **Pestizid-Paradoxon**: Dieselben Tests finden irgendwann keine neuen Fehler mehr\n6. **Testen ist kontextabhängig**: Verschiedene Systeme erfordern verschiedene Teststrategien\n7. **Trugschluss der Fehlerfreiheit**: Fehlerfreie Software ist nicht automatisch nützlich\n\n## 2. Black Box Testing\n\n### 2.1 Definition\n\nBeim Black Box Testing wird die Software ohne Kenntnis der internen Struktur getestet. Der Tester kennt nur die Spezifikation (Eingaben und erwartete Ausgaben).\n\n**Metapher**: Die Software ist eine \"schwarze Box\" - man sieht nur, was hineingeht und was herauskommt.\n\n### 2.2 Vorteile\n\n- Unabhängig von der Implementierung\n- Tester benötigen keine Programmierkenntnisse\n- Tests können früh (parallel zur Entwicklung) erstellt werden\n- Fokus auf Benutzerperspektive\n- Findet Fehler in der Spezifikation\n\n### 2.3 Nachteile\n\n- Nicht alle Codepfade werden getestet\n- Redundante Tests möglich\n- Schwierig, versteckte Fehler zu finden\n\n### 2.4 Black Box Testverfahren\n\n#### Äquivalenzklassenbildung\n\nEingabewerte werden in Klassen gruppiert, die ähnlich behandelt werden.\n\n**Beispiel: Altersvalidierung (18-65 Jahre)**\n\n```\nGültige Äquivalenzklasse:\n- 18 ≤ Alter ≤ 65\n- Testfall: Alter = 30\n\nUngültige Äquivalenzklassen:\n- Alter < 18\n- Testfall: Alter = 10\n\n- Alter > 65\n- Testfall: Alter = 70\n\n- Keine Zahl\n- Testfall: Alter = \"abc\"\n```\n\n#### Grenzwertanalyse\n\nTests konzentrieren sich auf die Grenzen von Äquivalenzklassen, da dort häufig Fehler auftreten.\n\n**Beispiel: Altersvalidierung (18-65 Jahre)**\n\n```\nTestfälle:\n- 17 (ungültig, unter Grenze)\n- 18 (gültig, untere Grenze)\n- 19 (gültig, über unterer Grenze)\n- 64 (gültig, unter oberer Grenze)\n- 65 (gültig, obere Grenze)\n- 66 (ungültig, über Grenze)\n```\n\n#### Zustandsbasiertes Testen\n\nTesten von Zustandsübergängen in zustandsbasierten Systemen.\n\n**Beispiel: Bestellstatus**\n\n```\nZustände:\n- Neu\n- Bezahlt\n- Versendet\n- Geliefert\n- Storniert\n\nÜbergänge testen:\n- Neu → Bezahlt (gültig)\n- Neu → Versendet (ungültig)\n- Bezahlt → Storniert (gültig)\n- Geliefert → Neu (ungültig)\n```\n\n### 2.5 Extremwertetest\n\nExtremwertetests prüfen das Verhalten bei extremen Eingabewerten.\n\n**Beispiele:**\n\n```\nString-Länge:\n- Leerer String: \"\"\n- Sehr langer String: 10.000 Zeichen\n- Maximale Länge: Datenbankfeld-Limit\n\nZahlen:\n- Minimum: Integer.MIN_VALUE\n- Maximum: Integer.MAX_VALUE\n- Null: 0\n- Negativ: -1\n\nListen:\n- Leere Liste: []\n- Ein Element: [1]\n- Viele Elemente: 1.000.000 Einträge\n\nDatum:\n- 01.01.1970 (Unix-Epoch)\n- 31.12.9999 (Maximaldatum)\n- 29.02.2024 (Schaltjahr)\n- 29.02.2023 (kein Schaltjahr)\n```\n\n## 3. White Box Testing\n\n### 3.1 Definition\n\nBeim White Box Testing wird die Software mit Kenntnis der internen Struktur getestet. Der Tester kennt den Quellcode und die Architektur.\n\n**Metapher**: Die Software ist eine \"gläserne Box\" - man sieht, wie sie intern funktioniert.\n\n### 3.2 Vorteile\n\n- Alle Codepfade können getestet werden\n- Findet versteckte Fehler\n- Optimierung möglich\n- Code-Coverage messbar\n\n### 3.3 Nachteile\n\n- Erfordert Programmierkenntnisse\n- Zeitaufwendig\n- Kann Spezifikationsfehler übersehen\n- Abhängig von der Implementierung\n\n### 3.4 White Box Testverfahren\n\n#### Anweisungsüberdeckung (Statement Coverage)\n\nJede Anweisung im Code wird mindestens einmal ausgeführt.\n\n**Beispiel:**\n\n```java\npublic int berechneRabatt(int alter, boolean istMitglied) {\n    int rabatt = 0;                    // Zeile 1\n    if (alter < 18) {                  // Zeile 2\n        rabatt = 10;                   // Zeile 3\n    }\n    if (istMitglied) {                 // Zeile 4\n        rabatt += 5;                   // Zeile 5\n    }\n    return rabatt;                     // Zeile 6\n}\n\n// Testfall für 100% Anweisungsüberdeckung:\nTest 1: berechneRabatt(15, true)\n// Führt alle Zeilen aus: 1, 2, 3, 4, 5, 6\n```\n\n#### Zweigüberdeckung (Branch Coverage)\n\nJeder Zweig (if/else) wird mindestens einmal durchlaufen.\n\n**Beispiel:**\n\n```java\npublic String pruefeNote(int punkte) {\n    if (punkte >= 50) {                // Zweig A\n        return \"Bestanden\";            // Zweig A-true\n    } else {\n        return \"Nicht bestanden\";      // Zweig A-false\n    }\n}\n\n// Testfälle für 100% Zweigüberdeckung:\nTest 1: pruefeNote(60)  // Zweig A-true\nTest 2: pruefeNote(30)  // Zweig A-false\n```\n\n#### Pfadüberdeckung (Path Coverage)\n\nAlle möglichen Pfade durch den Code werden getestet.\n\n**Beispiel:**\n\n```java\npublic int berechnePreis(boolean istMitglied, boolean istStudent) {\n    int preis = 100;\n    if (istMitglied) {                 // Bedingung 1\n        preis -= 10;\n    }\n    if (istStudent) {                  // Bedingung 2\n        preis -= 20;\n    }\n    return preis;\n}\n\n// Alle Pfade:\nTest 1: berechnePreis(false, false) // Pfad: keine Rabatte\nTest 2: berechnePreis(true, false)  // Pfad: nur Mitgliederrabatt\nTest 3: berechnePreis(false, true)  // Pfad: nur Studentenrabatt\nTest 4: berechnePreis(true, true)   // Pfad: beide Rabatte\n```\n\n## 4. Code Review\n\n### 4.1 Definition\n\nCode Review ist die systematische Überprüfung von Quellcode durch andere Entwickler.\n\n### 4.2 Arten von Reviews\n\n#### Informelles Review\n- Spontane Code-Durchsicht\n- Keine formale Struktur\n- Schnelles Feedback\n\n#### Walkthrough\n- Autor führt durch den Code\n- Team stellt Fragen\n- Fokus auf Verständnis\n\n#### Technisches Review\n- Formaler Prozess\n- Fokus auf technische Qualität\n- Dokumentierte Ergebnisse\n\n#### Inspektion (Formal Review)\n- Sehr formaler Prozess\n- Definierte Rollen (Moderator, Autor, Reviewer)\n- Checklisten\n- Metriken und Berichte\n\n### 4.3 Review-Checkliste\n\n**Funktionalität:**\n- ✓ Erfüllt der Code die Anforderungen?\n- ✓ Sind alle Edge Cases behandelt?\n- ✓ Ist die Fehlerbehandlung vollständig?\n\n**Code-Qualität:**\n- ✓ Ist der Code lesbar und verständlich?\n- ✓ Sind Variablen sinnvoll benannt?\n- ✓ Gibt es Code-Duplikate?\n- ✓ Ist der Code gut strukturiert?\n\n**Best Practices:**\n- ✓ Werden Coding Standards eingehalten?\n- ✓ Sind Kommentare vorhanden und hilfreich?\n- ✓ Ist der Code testbar?\n\n**Sicherheit:**\n- ✓ Sind Eingaben validiert?\n- ✓ Gibt es SQL-Injection-Risiken?\n- ✓ Sind sensible Daten geschützt?\n\n**Performance:**\n- ✓ Gibt es Performance-Probleme?\n- ✓ Sind Algorithmen effizient?\n- ✓ Werden Ressourcen korrekt freigegeben?\n\n## 5. Last- und Performancetests\n\n**NEU AB 2025**: Last- und Performancetests sind explizit prüfungsrelevant.\n\n### 5.1 Performancetest\n\n**Ziel**: Messen der Systemleistung unter normalen Bedingungen.\n\n**Metriken:**\n- **Antwortzeit**: Zeit von Anfrage bis Antwort\n- **Durchsatz**: Anzahl Transaktionen pro Zeiteinheit\n- **Ressourcennutzung**: CPU, RAM, Netzwerk\n\n**Beispiel:**\n```\nTest: Produktsuche\nErwartung: Antwortzeit < 2 Sekunden\nErgebnis: Durchschnitt 1,5 Sekunden\nStatus: ✓ Bestanden\n```\n\n### 5.2 Lasttest (Load Test)\n\n**Ziel**: Verhalten unter erwarteter Last prüfen.\n\n**Vorgehen:**\n1. Erwartete Benutzerzahl definieren\n2. Realistische Szenarien erstellen\n3. Last schrittweise erhöhen\n4. Metriken überwachen\n\n**Beispiel:**\n```\nSzenario: Online-Shop am Black Friday\n- Erwartete Benutzer: 10.000 gleichzeitig\n- Dauer: 4 Stunden\n- Aktionen: Suchen, Warenkorb, Checkout\n\nErgebnis:\n- Antwortzeit: 2,3 Sekunden (Ziel: < 3s) ✓\n- Fehlerrate: 0,1% (Ziel: < 1%) ✓\n- CPU-Auslastung: 75% (Ziel: < 80%) ✓\n```\n\n### 5.3 Stresstest\n\n**Ziel**: Grenzen des Systems finden.\n\n**Vorgehen:**\n1. Last kontinuierlich erhöhen\n2. Bis zum Systemausfall oder Leistungseinbruch\n3. Breaking Point identifizieren\n\n**Beispiel:**\n```\nTest: Maximale Benutzerzahl\nStart: 1.000 Benutzer\nSteigerung: +1.000 alle 5 Minuten\n\nErgebnis:\n- 15.000 Benutzer: System stabil\n- 18.000 Benutzer: Antwortzeit steigt auf 10s\n- 20.000 Benutzer: System nicht mehr erreichbar\n\nBreaking Point: ~18.000 Benutzer\n```\n\n### 5.4 Spike Test\n\n**Ziel**: Verhalten bei plötzlichen Lastspitzen prüfen.\n\n**Beispiel:**\n```\nSzenario: Newsletter-Versand\n- Normale Last: 100 Benutzer\n- Spike: 5.000 Benutzer innerhalb 1 Minute\n- Dauer: 10 Minuten\n- Rückkehr: Normale Last\n\nErgebnis:\n- System bleibt erreichbar ✓\n- Antwortzeit steigt kurzzeitig auf 8s\n- Erholt sich nach 5 Minuten ✓\n```\n\n### 5.5 Ausdauertest (Soak Test)\n\n**Ziel**: Stabilität über längeren Zeitraum prüfen.\n\n**Beispiel:**\n```\nTest: 24-Stunden-Betrieb\nLast: 5.000 Benutzer konstant\nDauer: 24 Stunden\n\nÜberwachung:\n- Memory Leaks\n- Datenbankverbindungen\n- Log-Dateien\n- Ressourcennutzung\n\nErgebnis:\n- Keine Memory Leaks ✓\n- Stabile Performance ✓\n- Keine Abstürze ✓\n```\n\n### 5.6 Tools für Last- und Performancetests\n\n**Beliebte Tools:**\n- **Apache JMeter**: Open Source, vielseitig\n- **Gatling**: Scala-basiert, gute Reports\n- **Locust**: Python-basiert, einfach zu schreiben\n- **K6**: JavaScript-basiert, Cloud-Integration\n- **LoadRunner**: Kommerziell, umfangreich\n\n## 6. Testpyramide\n\nDie Testpyramide zeigt die ideale Verteilung von Tests:\n\n```\n        /\\\n       /  \\     E2E Tests (wenige)\n      /    \\    - Langsam\n     /------\\   - Teuer\n    /        \\  \n   / Integr.  \\ Integrationstests (mittel)\n  /   Tests    \\\n /--------------\\\n/                \\\n/   Unit Tests   \\ Unit Tests (viele)\n/                 \\ - Schnell\n-------------------  - Günstig\n```\n\n**Empfohlene Verteilung:**\n- 70% Unit Tests\n- 20% Integrationstests\n- 10% End-to-End Tests\n\n## 7. Praktische Beispiele\n\n### Beispiel 1: Black Box Test für Login\n\n```\nTestfall 1: Gültige Anmeldung\nEingabe: \n  - Benutzername: \"max@example.com\"\n  - Passwort: \"Sicher123!\"\nErwartetes Ergebnis: Erfolgreich angemeldet\n\nTestfall 2: Ungültiges Passwort\nEingabe:\n  - Benutzername: \"max@example.com\"\n  - Passwort: \"falsch\"\nErwartetes Ergebnis: Fehlermeldung \"Ungültige Anmeldedaten\"\n\nTestfall 3: Leere Felder\nEingabe:\n  - Benutzername: \"\"\n  - Passwort: \"\"\nErwartetes Ergebnis: Fehlermeldung \"Felder dürfen nicht leer sein\"\n\nTestfall 4: SQL-Injection-Versuch\nEingabe:\n  - Benutzername: \"admin' OR '1'='1\"\n  - Passwort: \"test\"\nErwartetes Ergebnis: Fehlermeldung, kein Zugriff\n```\n\n### Beispiel 2: White Box Test für Rabattberechnung\n\n```java\npublic class RabattRechner {\n    public double berechneEndpreis(double preis, boolean istMitglied, int alter) {\n        double rabatt = 0;\n        \n        if (istMitglied) {\n            rabatt += 0.10; // 10% Mitgliederrabatt\n        }\n        \n        if (alter < 18) {\n            rabatt += 0.05; // 5% Jugendrabatt\n        } else if (alter >= 65) {\n            rabatt += 0.15; // 15% Seniorenrabatt\n        }\n        \n        return preis * (1 - rabatt);\n    }\n}\n\n// White Box Tests für alle Pfade:\n@Test\npublic void testKeinRabatt() {\n    // Pfad: kein Mitglied, Alter 30\n    assertEquals(100.0, rechner.berechneEndpreis(100, false, 30));\n}\n\n@Test\npublic void testNurMitgliederrabatt() {\n    // Pfad: Mitglied, Alter 30\n    assertEquals(90.0, rechner.berechneEndpreis(100, true, 30));\n}\n\n@Test\npublic void testMitgliedUndJugend() {\n    // Pfad: Mitglied, Alter 16\n    assertEquals(85.0, rechner.berechneEndpreis(100, true, 16));\n}\n\n@Test\npublic void testMitgliedUndSenior() {\n    // Pfad: Mitglied, Alter 70\n    assertEquals(75.0, rechner.berechneEndpreis(100, true, 70));\n}\n```\n\n## Prüfungsrelevante Punkte\n\n✓ Unterschied zwischen Black Box und White Box Testing\n✓ Äquivalenzklassenbildung und Grenzwertanalyse\n✓ Extremwertetests durchführen\n✓ Code Coverage (Anweisungs-, Zweig-, Pfadüberdeckung)\n✓ Code Review-Prozess und Checklisten\n✓ **NEU 2025**: Last- und Performancetests\n✓ Testpyramide und Testverteilung\n\n## Zusammenfassung\n\n**Black Box Testing:**\n- Testen ohne Kenntnis der internen Struktur\n- Fokus auf Spezifikation und Benutzerperspektive\n- Methoden: Äquivalenzklassen, Grenzwerte, Extremwerte\n\n**White Box Testing:**\n- Testen mit Kenntnis der internen Struktur\n- Fokus auf Code-Coverage\n- Methoden: Anweisungs-, Zweig-, Pfadüberdeckung\n\n**Code Review:**\n- Systematische Überprüfung durch andere Entwickler\n- Findet Fehler, verbessert Code-Qualität\n- Verschiedene Formalitätsgrade\n\n**Last- und Performancetests (NEU 2025):**\n- Performancetest: Leistung unter normalen Bedingungen\n- Lasttest: Verhalten unter erwarteter Last\n- Stresstest: Grenzen des Systems finden\n- Wichtig für produktionsreife Software",
  "codeExamples": [
    {
      "language": "java",
      "title": "Beispiel: Unit Test mit JUnit",
      "code": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class TaschenrechnerTest {\n    \n    private Taschenrechner rechner = new Taschenrechner();\n    \n    @Test\n    public void testAddition() {\n        // Arrange\n        int a = 5;\n        int b = 3;\n        \n        // Act\n        int ergebnis = rechner.addiere(a, b);\n        \n        // Assert\n        assertEquals(8, ergebnis, \"5 + 3 sollte 8 ergeben\");\n    }\n    \n    @Test\n    public void testDivisionDurchNull() {\n        // Assert & Act\n        assertThrows(ArithmeticException.class, () -> {\n            rechner.dividiere(10, 0);\n        }, \"Division durch Null sollte Exception werfen\");\n    }\n    \n    @Test\n    public void testGrenzwerte() {\n        // Test mit Integer.MAX_VALUE\n        assertEquals(Integer.MAX_VALUE, \n                     rechner.addiere(Integer.MAX_VALUE, 0));\n        \n        // Test mit negativen Zahlen\n        assertEquals(-5, rechner.addiere(-2, -3));\n    }\n}",
      "explanation": "Unit Tests prüfen einzelne Funktionen isoliert. Das AAA-Pattern (Arrange-Act-Assert) strukturiert Tests klar und verständlich."
    },
    {
      "language": "javascript",
      "title": "Beispiel: Lasttest mit K6",
      "code": "import http from 'k6/http';\nimport { check, sleep } from 'k6';\n\n// Testkonfiguration\nexport let options = {\n  stages: [\n    { duration: '2m', target: 100 },  // Hochfahren auf 100 Benutzer\n    { duration: '5m', target: 100 },  // 5 Minuten bei 100 Benutzern\n    { duration: '2m', target: 200 },  // Hochfahren auf 200 Benutzer\n    { duration: '5m', target: 200 },  // 5 Minuten bei 200 Benutzern\n    { duration: '2m', target: 0 },    // Herunterfahren\n  ],\n  thresholds: {\n    http_req_duration: ['p(95)<500'], // 95% der Requests < 500ms\n    http_req_failed: ['rate<0.01'],   // Fehlerrate < 1%\n  },\n};\n\nexport default function () {\n  // Produktsuche simulieren\n  let searchResponse = http.get('https://api.example.com/products?q=laptop');\n  \n  check(searchResponse, {\n    'Status ist 200': (r) => r.status === 200,\n    'Antwortzeit < 500ms': (r) => r.timings.duration < 500,\n    'Ergebnisse vorhanden': (r) => JSON.parse(r.body).results.length > 0,\n  });\n  \n  sleep(1); // 1 Sekunde Pause zwischen Requests\n  \n  // Produktdetails abrufen\n  let productId = JSON.parse(searchResponse.body).results[0].id;\n  let detailResponse = http.get(`https://api.example.com/products/${productId}`);\n  \n  check(detailResponse, {\n    'Status ist 200': (r) => r.status === 200,\n    'Produktname vorhanden': (r) => JSON.parse(r.body).name !== undefined,\n  });\n  \n  sleep(2);\n}",
      "explanation": "Lasttests simulieren viele gleichzeitige Benutzer und messen die Systemleistung. K6 ermöglicht realistische Lastszenarien mit JavaScript."
    }
  ],
  "relatedQuizzes": ["fue-03-quality-quiz"],
  "resources": [
    {
      "title": "ISTQB Foundation Level",
      "url": "https://www.istqb.org",
      "type": "documentation"
    },
    {
      "title": "K6 Load Testing",
      "url": "https://k6.io/docs",
      "type": "documentation"
    }
  ],
  "lastUpdated": "2025-01-10T00:00:00Z",
  "version": "1.0",
  "learningObjectives": [
    "Understand Software-Tests",
    "Understand Black Box",
    "Understand White Box",
    "Understand Review",
    "Understand Extremwertetest"
  ]
}
