{
  "id": "fue-02-anomalies-redundancies",
  "title": "Datenbank-Anomalien und Redundanzen",
  "description": "Verstehe Datenbank-Anomalien (Einfüge-, Änderungs-, Lösch-Anomalie), Redundanzen und wie Normalisierung diese Probleme löst.",
  "category": "FÜ-02",
  "subcategory": "Entwickeln und Bereitstellen von Softwareanwendungen - Datenbankdesign",
  "difficulty": "intermediate",
  "examRelevance": "high",
  "newIn2025": true,
  "removedIn2025": false,
  "important": true,
  "estimatedTime": 50,
  "prerequisites": ["fue-02-development"],
  "tags": [
    "datenbank",
    "anomalien",
    "redundanzen",
    "normalisierung",
    "normalformen",
    "datenbankdesign"
  ],
  "content": "# Datenbank-Anomalien und Redundanzen\n\n## Übersicht\n\nBei schlecht designten Datenbanken können **Anomalien** und **Redundanzen** auftreten, die zu Inkonsistenzen, Speicherverschwendung und Wartungsproblemen führen. Die **Normalisierung** ist der Prozess, diese Probleme zu vermeiden.\n\n## Was sind Redundanzen?\n\n**Redundanz** bedeutet, dass dieselben Daten mehrfach in der Datenbank gespeichert werden.\n\n### Beispiel: Unnormalisierte Tabelle\n\n```\nBestellungen (nicht normalisiert)\n┌────────┬──────────────┬─────────────┬──────────────┬─────────┬──────────┐\n│ Best_ID│ Kunde_Name   │ Kunde_Adresse│ Produkt_Name │ Menge   │ Preis    │\n├────────┼──────────────┼─────────────┼──────────────┼─────────┼──────────┤\n│ 1      │ Max Müller   │ Berlin      │ Laptop       │ 1       │ 999.00   │\n│ 2      │ Max Müller   │ Berlin      │ Maus         │ 2       │ 19.99    │\n│ 3      │ Anna Schmidt │ Hamburg     │ Laptop       │ 1       │ 999.00   │\n│ 4      │ Max Müller   │ Berlin      │ Tastatur     │ 1       │ 49.99    │\n└────────┴──────────────┴─────────────┴──────────────┴─────────┴──────────┘\n```\n\n**Probleme:**\n- \"Max Müller\" und \"Berlin\" werden 3x gespeichert (Redundanz)\n- \"Laptop\" und \"999.00\" werden 2x gespeichert (Redundanz)\n- Speicherverschwendung\n- Inkonsistenzgefahr bei Änderungen\n\n### Folgen von Redundanzen\n\n❌ **Speicherverschwendung**: Daten werden mehrfach gespeichert\n❌ **Inkonsistenzen**: Änderungen müssen an mehreren Stellen erfolgen\n❌ **Wartungsaufwand**: Höherer Aufwand bei Updates\n❌ **Performance**: Größere Tabellen, langsamere Queries\n\n## Datenbank-Anomalien\n\nAnomalien sind **unerwünschte Nebeneffekte** bei Datenoperationen in schlecht designten Datenbanken.\n\n### 1. Einfüge-Anomalie (Insert Anomaly)\n\n**Problem**: Daten können nicht eingefügt werden, ohne andere, nicht verfügbare Daten einzufügen.\n\n#### Beispiel\n\n```\nMitarbeiter_Projekte\n┌──────────┬──────────────┬──────────┬──────────────┬──────────────┐\n│ MA_ID    │ MA_Name      │ Abteilung│ Projekt_ID   │ Projekt_Name │\n├──────────┼──────────────┼──────────┼──────────────┼──────────────┤\n│ 1        │ Alice        │ IT       │ P1           │ Website      │\n│ 2        │ Bob          │ IT       │ P2           │ App          │\n│ 3        │ Charlie      │ HR       │ P1           │ Website      │\n└──────────┴──────────────┴──────────┴──────────────┴──────────────┘\n```\n\n**Problem:**\n- Neuer Mitarbeiter \"David\" wird eingestellt, aber noch keinem Projekt zugewiesen\n- Kann nicht eingefügt werden, da Projekt_ID und Projekt_Name erforderlich sind\n- Workaround: NULL-Werte oder Dummy-Daten → Schlechte Lösung!\n\n**Lösung durch Normalisierung:**\n```\nMitarbeiter                    Projekte\n┌──────┬────────┬──────────┐  ┌──────────┬──────────────┐\n│ MA_ID│ Name   │ Abteilung│  │ Projekt_ID│ Projekt_Name │\n├──────┼────────┼──────────┤  ├──────────┼──────────────┤\n│ 1    │ Alice  │ IT       │  │ P1       │ Website      │\n│ 2    │ Bob    │ IT       │  │ P2       │ App          │\n│ 3    │ Charlie│ HR       │  └──────────┴──────────────┘\n│ 4    │ David  │ IT       │  \n└──────┴────────┴──────────┘  \n\nMitarbeiter_Projekte (Zuordnungstabelle)\n┌──────┬──────────┐\n│ MA_ID│ Projekt_ID│\n├──────┼──────────┤\n│ 1    │ P1       │\n│ 2    │ P2       │\n│ 3    │ P1       │\n└──────┴──────────┘\n```\n\nJetzt kann David eingefügt werden, ohne einem Projekt zugeordnet zu sein!\n\n### 2. Änderungs-Anomalie (Update Anomaly)\n\n**Problem**: Änderungen müssen an mehreren Stellen durchgeführt werden, sonst entstehen Inkonsistenzen.\n\n#### Beispiel\n\n```\nBestellungen (nicht normalisiert)\n┌────────┬──────────────┬─────────────┬──────────────┬─────────┐\n│ Best_ID│ Kunde_Name   │ Kunde_Adresse│ Produkt_Name │ Menge   │\n├────────┼──────────────┼─────────────┼──────────────┼─────────┤\n│ 1      │ Max Müller   │ Berlin      │ Laptop       │ 1       │\n│ 2      │ Max Müller   │ Berlin      │ Maus         │ 2       │\n│ 3      │ Max Müller   │ Berlin      │ Tastatur     │ 1       │\n└────────┴──────────────┴─────────────┴──────────────┴─────────┘\n```\n\n**Problem:**\n- Max Müller zieht von Berlin nach München\n- Adresse muss in **allen 3 Zeilen** geändert werden\n- Wenn eine Zeile vergessen wird → **Inkonsistenz**!\n\n```sql\n-- Fehleranfällig: Muss alle Zeilen updaten\nUPDATE Bestellungen\nSET Kunde_Adresse = 'München'\nWHERE Kunde_Name = 'Max Müller';\n```\n\n**Lösung durch Normalisierung:**\n```\nKunden                         Bestellungen\n┌────────┬──────────────┬─────────┐  ┌────────┬──────────┬──────────────┬─────┐\n│ Kunde_ID│ Name        │ Adresse │  │ Best_ID│ Kunde_ID │ Produkt_Name │Menge│\n├────────┼──────────────┼─────────┤  ├────────┼──────────┼──────────────┼─────┤\n│ 1      │ Max Müller   │ Berlin  │  │ 1      │ 1        │ Laptop       │ 1   │\n└────────┴──────────────┴─────────┘  │ 2      │ 1        │ Maus         │ 2   │\n                                      │ 3      │ 1        │ Tastatur     │ 1   │\n                                      └────────┴──────────┴──────────────┴─────┘\n```\n\n```sql\n-- Einfach: Nur eine Zeile updaten\nUPDATE Kunden\nSET Adresse = 'München'\nWHERE Kunde_ID = 1;\n```\n\n### 3. Lösch-Anomalie (Delete Anomaly)\n\n**Problem**: Beim Löschen von Daten gehen ungewollt andere Informationen verloren.\n\n#### Beispiel\n\n```\nMitarbeiter_Projekte\n┌──────────┬──────────────┬──────────┬──────────────┬──────────────┐\n│ MA_ID    │ MA_Name      │ Abteilung│ Projekt_ID   │ Projekt_Name │\n├──────────┼──────────────┼──────────┼──────────────┼──────────────┤\n│ 1        │ Alice        │ IT       │ P1           │ Website      │\n│ 2        │ Bob          │ IT       │ P2           │ App          │\n│ 3        │ Charlie      │ HR       │ P3           │ Recruiting   │\n└──────────┴──────────────┴──────────┴──────────────┴──────────────┘\n```\n\n**Problem:**\n- Charlie verlässt das Unternehmen und wird gelöscht\n- Dabei geht die Information über Projekt P3 \"Recruiting\" verloren!\n- Das Projekt existiert noch, aber die Daten sind weg\n\n```sql\n-- Löscht Mitarbeiter UND Projekt-Info\nDELETE FROM Mitarbeiter_Projekte\nWHERE MA_ID = 3;\n```\n\n**Lösung durch Normalisierung:**\n```\nMitarbeiter                    Projekte\n┌──────┬────────┬──────────┐  ┌──────────┬──────────────┐\n│ MA_ID│ Name   │ Abteilung│  │ Projekt_ID│ Projekt_Name │\n├──────┼────────┼──────────┤  ├──────────┼──────────────┤\n│ 1    │ Alice  │ IT       │  │ P1       │ Website      │\n│ 2    │ Bob    │ IT       │  │ P2       │ App          │\n│ 3    │ Charlie│ HR       │  │ P3       │ Recruiting   │\n└──────┴────────┴──────────┘  └──────────┴──────────────┘\n\nMitarbeiter_Projekte\n┌──────┬──────────┐\n│ MA_ID│ Projekt_ID│\n├──────┼──────────┤\n│ 1    │ P1       │\n│ 2    │ P2       │\n│ 3    │ P3       │\n└──────┴──────────┘\n```\n\n```sql\n-- Löscht nur Mitarbeiter, Projekt bleibt erhalten\nDELETE FROM Mitarbeiter WHERE MA_ID = 3;\nDELETE FROM Mitarbeiter_Projekte WHERE MA_ID = 3;\n-- Projekt P3 existiert weiterhin in Projekte-Tabelle!\n```\n\n## Normalisierung\n\n**Normalisierung** ist der Prozess, Datenbanken so zu strukturieren, dass Redundanzen und Anomalien minimiert werden.\n\n### Normalformen - Übersicht\n\n```\nUnnormalisiert\n    ↓ Atomare Werte\n1. Normalform (1NF)\n    ↓ Volle funktionale Abhängigkeit\n2. Normalform (2NF)\n    ↓ Keine transitiven Abhängigkeiten\n3. Normalform (3NF)\n    ↓ Keine mehrwertigen Abhängigkeiten\nBoyce-Codd Normalform (BCNF)\n    ↓ Weitere Normalisierung\n4. Normalform (4NF)\n    ↓\n5. Normalform (5NF)\n```\n\n### 1. Normalform (1NF)\n\n**Regel**: Alle Attribute müssen **atomar** sein (keine Listen, keine zusammengesetzten Werte).\n\n#### Beispiel: Nicht in 1NF\n\n```\nKunden\n┌────────┬──────────────┬─────────────────────────┐\n│ Kunde_ID│ Name        │ Telefonnummern          │\n├────────┼──────────────┼─────────────────────────┤\n│ 1      │ Max Müller   │ 030-123, 0170-456       │  ❌ Nicht atomar!\n│ 2      │ Anna Schmidt │ 040-789                 │\n└────────┴──────────────┴─────────────────────────┘\n```\n\n#### Lösung: In 1NF\n\n```\nKunden                         Telefonnummern\n┌────────┬──────────────┐      ┌────────┬──────────────┐\n│ Kunde_ID│ Name        │      │ Kunde_ID│ Telefonnummer│\n├────────┼──────────────┤      ├────────┼──────────────┤\n│ 1      │ Max Müller   │      │ 1      │ 030-123      │\n│ 2      │ Anna Schmidt │      │ 1      │ 0170-456     │\n└────────┴──────────────┘      │ 2      │ 040-789      │\n                                └────────┴──────────────┘\n```\n\n### 2. Normalform (2NF)\n\n**Regel**: Muss in 1NF sein + Alle Nicht-Schlüssel-Attribute müssen **voll funktional abhängig** vom Primärschlüssel sein.\n\n**Gilt nur für zusammengesetzte Primärschlüssel!**\n\n#### Beispiel: Nicht in 2NF\n\n```\nBestellpositionen\n┌────────┬──────────┬──────────────┬─────────┬──────────────┐\n│ Best_ID│ Produkt_ID│ Produkt_Name │ Menge   │ Preis        │\n└────────┴──────────┴──────────────┴─────────┴──────────────┘\n         └──────────┘\n    Primärschlüssel (zusammengesetzt)\n```\n\n**Problem:**\n- `Produkt_Name` hängt nur von `Produkt_ID` ab, nicht von `Best_ID`\n- Partielle Abhängigkeit → Nicht in 2NF!\n\n#### Lösung: In 2NF\n\n```\nProdukte                       Bestellpositionen\n┌──────────┬──────────────┬──────┐  ┌────────┬──────────┬─────────┐\n│ Produkt_ID│ Produkt_Name │ Preis│  │ Best_ID│ Produkt_ID│ Menge   │\n├──────────┼──────────────┼──────┤  ├────────┼──────────┼─────────┤\n│ 1        │ Laptop       │ 999  │  │ 1      │ 1        │ 1       │\n│ 2        │ Maus         │ 19.99│  │ 1      │ 2        │ 2       │\n└──────────┴──────────────┴──────┘  └────────┴──────────┴─────────┘\n```\n\n### 3. Normalform (3NF)\n\n**Regel**: Muss in 2NF sein + Keine **transitiven Abhängigkeiten** (Nicht-Schlüssel-Attribute dürfen nicht von anderen Nicht-Schlüssel-Attributen abhängen).\n\n#### Beispiel: Nicht in 3NF\n\n```\nMitarbeiter\n┌──────┬────────┬──────────┬──────────────────┐\n│ MA_ID│ Name   │ Abt_ID   │ Abt_Name         │\n├──────┼────────┼──────────┼──────────────────┤\n│ 1    │ Alice  │ 10       │ IT               │\n│ 2    │ Bob    │ 10       │ IT               │\n│ 3    │ Charlie│ 20       │ HR               │\n└──────┴────────┴──────────┴──────────────────┘\n```\n\n**Problem:**\n- `Abt_Name` hängt von `Abt_ID` ab, nicht direkt von `MA_ID`\n- Transitive Abhängigkeit: MA_ID → Abt_ID → Abt_Name\n- Nicht in 3NF!\n\n#### Lösung: In 3NF\n\n```\nMitarbeiter                    Abteilungen\n┌──────┬────────┬──────────┐  ┌──────────┬──────────┐\n│ MA_ID│ Name   │ Abt_ID   │  │ Abt_ID   │ Abt_Name │\n├──────┼────────┼──────────┤  ├──────────┼──────────┤\n│ 1    │ Alice  │ 10       │  │ 10       │ IT       │\n│ 2    │ Bob    │ 10       │  │ 20       │ HR       │\n│ 3    │ Charlie│ 20       │  └──────────┴──────────┘\n└──────┴────────┴──────────┘\n```\n\n## Vor- und Nachteile der Normalisierung\n\n### Vorteile\n\n✅ **Keine Redundanzen**: Daten werden nur einmal gespeichert\n✅ **Keine Anomalien**: Einfüge-, Änderungs- und Lösch-Anomalien werden vermieden\n✅ **Datenintegrität**: Konsistente Daten\n✅ **Wartbarkeit**: Einfachere Änderungen\n✅ **Speichereffizienz**: Weniger Speicherplatz\n\n### Nachteile\n\n❌ **Komplexere Queries**: Mehr JOINs erforderlich\n❌ **Performance**: JOINs können langsamer sein\n❌ **Mehr Tabellen**: Komplexere Datenbankstruktur\n\n## Denormalisierung\n\nIn manchen Fällen wird bewusst **denormalisiert**, um Performance zu verbessern:\n\n### Wann Denormalisierung?\n\n- **Read-Heavy Anwendungen**: Viele Lesezugriffe, wenige Schreibzugriffe\n- **Performance-kritisch**: JOINs zu langsam\n- **Data Warehousing**: Analytische Datenbanken\n- **Caching**: Häufig abgefragte Daten\n\n### Beispiel: Denormalisierung für Performance\n\n```sql\n-- Normalisiert (3 JOINs)\nSELECT \n    b.Best_ID,\n    k.Name AS Kunde_Name,\n    p.Produkt_Name,\n    bp.Menge,\n    p.Preis\nFROM Bestellungen b\nJOIN Kunden k ON b.Kunde_ID = k.Kunde_ID\nJOIN Bestellpositionen bp ON b.Best_ID = bp.Best_ID\nJOIN Produkte p ON bp.Produkt_ID = p.Produkt_ID;\n\n-- Denormalisiert (kein JOIN)\nSELECT \n    Best_ID,\n    Kunde_Name,\n    Produkt_Name,\n    Menge,\n    Preis\nFROM Bestellungen_Denormalisiert;\n```\n\n**Trade-off**: Schnellere Queries, aber Redundanzen und Anomalien!\n\n## Zusammenfassung\n\n### Anomalien\n\n1. **Einfüge-Anomalie**: Daten können nicht eingefügt werden ohne andere Daten\n2. **Änderungs-Anomalie**: Änderungen müssen an mehreren Stellen erfolgen\n3. **Lösch-Anomalie**: Beim Löschen gehen ungewollt andere Daten verloren\n\n### Redundanzen\n\n- Mehrfache Speicherung derselben Daten\n- Führt zu Speicherverschwendung und Inkonsistenzen\n\n### Normalisierung\n\n- **1NF**: Atomare Werte\n- **2NF**: Volle funktionale Abhängigkeit vom Primärschlüssel\n- **3NF**: Keine transitiven Abhängigkeiten\n\n### Für die IHK-Prüfung wichtig:\n\n- Erkenne Anomalien in Beispiel-Tabellen\n- Verstehe, wie Normalisierung Probleme löst\n- Kenne die ersten drei Normalformen\n- Verstehe den Trade-off zwischen Normalisierung und Performance",
  "codeExamples": [
    {
      "language": "sql",
      "title": "Unnormalisierte Tabelle mit Anomalien",
      "code": "-- Unnormalisierte Tabelle (0NF)\nCREATE TABLE Bestellungen_Unnormalisiert (\n    Best_ID INT PRIMARY KEY,\n    Kunde_Name VARCHAR(100),\n    Kunde_Adresse VARCHAR(200),\n    Kunde_Telefon VARCHAR(50),\n    Produkt_Name VARCHAR(100),\n    Produkt_Kategorie VARCHAR(50),\n    Menge INT,\n    Einzelpreis DECIMAL(10,2),\n    Gesamtpreis DECIMAL(10,2)\n);\n\n-- Beispieldaten mit Redundanzen\nINSERT INTO Bestellungen_Unnormalisiert VALUES\n(1, 'Max Müller', 'Berlin, Hauptstr. 1', '030-123456', 'Laptop', 'Elektronik', 1, 999.00, 999.00),\n(2, 'Max Müller', 'Berlin, Hauptstr. 1', '030-123456', 'Maus', 'Elektronik', 2, 19.99, 39.98),\n(3, 'Max Müller', 'Berlin, Hauptstr. 1', '030-123456', 'Tastatur', 'Elektronik', 1, 49.99, 49.99),\n(4, 'Anna Schmidt', 'Hamburg, Seestr. 5', '040-789012', 'Laptop', 'Elektronik', 1, 999.00, 999.00);\n\n-- PROBLEM 1: Änderungs-Anomalie\n-- Max Müller zieht um - muss in ALLEN Zeilen geändert werden!\nUPDATE Bestellungen_Unnormalisiert\nSET Kunde_Adresse = 'München, Bergstr. 10'\nWHERE Kunde_Name = 'Max Müller';\n-- Wenn eine Zeile vergessen wird → Inkonsistenz!\n\n-- PROBLEM 2: Einfüge-Anomalie\n-- Neuer Kunde ohne Bestellung kann nicht eingefügt werden\n-- INSERT INTO Bestellungen_Unnormalisiert (Kunde_Name, Kunde_Adresse) \n-- VALUES ('Peter Klein', 'Köln, Rheinstr. 3');\n-- ❌ Fehler: Produkt_Name, Menge etc. sind erforderlich!\n\n-- PROBLEM 3: Lösch-Anomalie\n-- Wenn Anna Schmidt ihre Bestellung storniert, gehen alle Kundendaten verloren\nDELETE FROM Bestellungen_Unnormalisiert WHERE Best_ID = 4;\n-- ❌ Kundendaten von Anna Schmidt sind komplett weg!",
      "explanation": "Zeigt eine unnormalisierte Tabelle mit allen drei Anomalie-Typen. Demonstriert die Probleme bei Update, Insert und Delete."
    },
    {
      "language": "sql",
      "title": "Normalisierte Datenbank (3NF)",
      "code": "-- Normalisierte Struktur (3NF)\n\n-- 1. Kunden-Tabelle\nCREATE TABLE Kunden (\n    Kunde_ID INT PRIMARY KEY AUTO_INCREMENT,\n    Name VARCHAR(100) NOT NULL,\n    Adresse VARCHAR(200),\n    Telefon VARCHAR(50)\n);\n\n-- 2. Produkt-Kategorien\nCREATE TABLE Kategorien (\n    Kategorie_ID INT PRIMARY KEY AUTO_INCREMENT,\n    Kategorie_Name VARCHAR(50) NOT NULL UNIQUE\n);\n\n-- 3. Produkte-Tabelle\nCREATE TABLE Produkte (\n    Produkt_ID INT PRIMARY KEY AUTO_INCREMENT,\n    Produkt_Name VARCHAR(100) NOT NULL,\n    Kategorie_ID INT,\n    Preis DECIMAL(10,2) NOT NULL,\n    FOREIGN KEY (Kategorie_ID) REFERENCES Kategorien(Kategorie_ID)\n);\n\n-- 4. Bestellungen-Tabelle\nCREATE TABLE Bestellungen (\n    Best_ID INT PRIMARY KEY AUTO_INCREMENT,\n    Kunde_ID INT NOT NULL,\n    Bestelldatum DATE DEFAULT CURRENT_DATE,\n    FOREIGN KEY (Kunde_ID) REFERENCES Kunden(Kunde_ID)\n);\n\n-- 5. Bestellpositionen-Tabelle\nCREATE TABLE Bestellpositionen (\n    Position_ID INT PRIMARY KEY AUTO_INCREMENT,\n    Best_ID INT NOT NULL,\n    Produkt_ID INT NOT NULL,\n    Menge INT NOT NULL CHECK (Menge > 0),\n    FOREIGN KEY (Best_ID) REFERENCES Bestellungen(Best_ID) ON DELETE CASCADE,\n    FOREIGN KEY (Produkt_ID) REFERENCES Produkte(Produkt_ID)\n);\n\n-- Daten einfügen\nINSERT INTO Kunden (Name, Adresse, Telefon) VALUES\n('Max Müller', 'Berlin, Hauptstr. 1', '030-123456'),\n('Anna Schmidt', 'Hamburg, Seestr. 5', '040-789012'),\n('Peter Klein', 'Köln, Rheinstr. 3', '0221-345678');  -- ✅ Kunde ohne Bestellung möglich!\n\nINSERT INTO Kategorien (Kategorie_Name) VALUES\n('Elektronik'),\n('Bücher'),\n('Kleidung');\n\nINSERT INTO Produkte (Produkt_Name, Kategorie_ID, Preis) VALUES\n('Laptop', 1, 999.00),\n('Maus', 1, 19.99),\n('Tastatur', 1, 49.99);\n\nINSERT INTO Bestellungen (Kunde_ID) VALUES\n(1),  -- Max Müller\n(2);  -- Anna Schmidt\n\nINSERT INTO Bestellpositionen (Best_ID, Produkt_ID, Menge) VALUES\n(1, 1, 1),  -- Max: 1x Laptop\n(1, 2, 2),  -- Max: 2x Maus\n(1, 3, 1),  -- Max: 1x Tastatur\n(2, 1, 1);  -- Anna: 1x Laptop\n\n-- LÖSUNG 1: Änderungs-Anomalie behoben\n-- Max Müller zieht um - nur EINE Zeile ändern!\nUPDATE Kunden\nSET Adresse = 'München, Bergstr. 10'\nWHERE Kunde_ID = 1;\n-- ✅ Alle Bestellungen zeigen automatisch neue Adresse!\n\n-- LÖSUNG 2: Einfüge-Anomalie behoben\n-- Peter Klein wurde bereits ohne Bestellung eingefügt (siehe oben)\n-- ✅ Kein Problem!\n\n-- LÖSUNG 3: Lösch-Anomalie behoben\n-- Anna Schmidt storniert Bestellung\nDELETE FROM Bestellungen WHERE Best_ID = 2;\n-- ✅ Kundendaten bleiben erhalten!\nSELECT * FROM Kunden WHERE Kunde_ID = 2;  -- Anna ist noch da!",
      "explanation": "Zeigt die normalisierte Datenbankstruktur (3NF) mit separaten Tabellen. Alle Anomalien sind behoben."
    },
    {
      "language": "sql",
      "title": "Normalisierung Schritt für Schritt",
      "code": "-- Ausgangstabelle (0NF)\nCREATE TABLE Mitarbeiter_Projekte_0NF (\n    MA_ID INT,\n    MA_Name VARCHAR(100),\n    MA_Skills VARCHAR(200),  -- ❌ Nicht atomar: \"Java, Python, SQL\"\n    Abt_ID INT,\n    Abt_Name VARCHAR(50),\n    Projekt_ID INT,\n    Projekt_Name VARCHAR(100),\n    Projekt_Budget DECIMAL(10,2)\n);\n\n-- Schritt 1: 1. Normalform (1NF) - Atomare Werte\n-- Skills in separate Tabelle auslagern\nCREATE TABLE Mitarbeiter_1NF (\n    MA_ID INT PRIMARY KEY,\n    MA_Name VARCHAR(100),\n    Abt_ID INT,\n    Abt_Name VARCHAR(50),\n    Projekt_ID INT,\n    Projekt_Name VARCHAR(100),\n    Projekt_Budget DECIMAL(10,2)\n);\n\nCREATE TABLE Mitarbeiter_Skills_1NF (\n    MA_ID INT,\n    Skill VARCHAR(50),\n    PRIMARY KEY (MA_ID, Skill)\n);\n-- ✅ Alle Werte sind jetzt atomar\n\n-- Schritt 2: 2. Normalform (2NF) - Volle funktionale Abhängigkeit\n-- Projekt-Daten hängen nur von Projekt_ID ab, nicht von MA_ID\nCREATE TABLE Mitarbeiter_2NF (\n    MA_ID INT PRIMARY KEY,\n    MA_Name VARCHAR(100),\n    Abt_ID INT,\n    Abt_Name VARCHAR(50)\n);\n\nCREATE TABLE Projekte_2NF (\n    Projekt_ID INT PRIMARY KEY,\n    Projekt_Name VARCHAR(100),\n    Projekt_Budget DECIMAL(10,2)\n);\n\nCREATE TABLE Mitarbeiter_Projekte_2NF (\n    MA_ID INT,\n    Projekt_ID INT,\n    PRIMARY KEY (MA_ID, Projekt_ID),\n    FOREIGN KEY (MA_ID) REFERENCES Mitarbeiter_2NF(MA_ID),\n    FOREIGN KEY (Projekt_ID) REFERENCES Projekte_2NF(Projekt_ID)\n);\n-- ✅ Keine partiellen Abhängigkeiten mehr\n\n-- Schritt 3: 3. Normalform (3NF) - Keine transitiven Abhängigkeiten\n-- Abt_Name hängt von Abt_ID ab, nicht direkt von MA_ID\nCREATE TABLE Mitarbeiter_3NF (\n    MA_ID INT PRIMARY KEY,\n    MA_Name VARCHAR(100),\n    Abt_ID INT,\n    FOREIGN KEY (Abt_ID) REFERENCES Abteilungen_3NF(Abt_ID)\n);\n\nCREATE TABLE Abteilungen_3NF (\n    Abt_ID INT PRIMARY KEY,\n    Abt_Name VARCHAR(50)\n);\n\nCREATE TABLE Projekte_3NF (\n    Projekt_ID INT PRIMARY KEY,\n    Projekt_Name VARCHAR(100),\n    Projekt_Budget DECIMAL(10,2)\n);\n\nCREATE TABLE Mitarbeiter_Projekte_3NF (\n    MA_ID INT,\n    Projekt_ID INT,\n    PRIMARY KEY (MA_ID, Projekt_ID),\n    FOREIGN KEY (MA_ID) REFERENCES Mitarbeiter_3NF(MA_ID),\n    FOREIGN KEY (Projekt_ID) REFERENCES Projekte_3NF(Projekt_ID)\n);\n\nCREATE TABLE Mitarbeiter_Skills_3NF (\n    MA_ID INT,\n    Skill VARCHAR(50),\n    PRIMARY KEY (MA_ID, Skill),\n    FOREIGN KEY (MA_ID) REFERENCES Mitarbeiter_3NF(MA_ID)\n);\n-- ✅ Keine transitiven Abhängigkeiten mehr - 3NF erreicht!",
      "explanation": "Zeigt den schrittweisen Normalisierungsprozess von 0NF bis 3NF. Jeder Schritt behebt spezifische Probleme."
    },
    {
      "language": "sql",
      "title": "Anomalien erkennen und beheben",
      "code": "-- Beispiel: Bibliothekssystem mit Anomalien\nCREATE TABLE Ausleihen_Problematisch (\n    Ausleihe_ID INT PRIMARY KEY,\n    Buch_Titel VARCHAR(200),\n    Buch_ISBN VARCHAR(20),\n    Buch_Autor VARCHAR(100),\n    Buch_Verlag VARCHAR(100),\n    Verlag_Adresse VARCHAR(200),  -- ❌ Transitive Abhängigkeit!\n    Leser_Name VARCHAR(100),\n    Leser_Email VARCHAR(100),\n    Ausleihdatum DATE,\n    Rückgabedatum DATE\n);\n\n-- PROBLEM-ANALYSE:\n-- 1. Buch-Daten (Titel, ISBN, Autor, Verlag) werden bei jeder Ausleihe dupliziert\n-- 2. Verlag_Adresse hängt von Verlag ab (transitive Abhängigkeit)\n-- 3. Leser-Daten werden bei jeder Ausleihe dupliziert\n-- 4. Wenn ein Buch nie ausgeliehen wird, kann es nicht gespeichert werden (Einfüge-Anomalie)\n\n-- LÖSUNG: Normalisierte Struktur\n\n-- Verlage (separate Tabelle)\nCREATE TABLE Verlage (\n    Verlag_ID INT PRIMARY KEY AUTO_INCREMENT,\n    Verlag_Name VARCHAR(100) UNIQUE NOT NULL,\n    Adresse VARCHAR(200)\n);\n\n-- Bücher (mit Referenz auf Verlag)\nCREATE TABLE Buecher (\n    Buch_ID INT PRIMARY KEY AUTO_INCREMENT,\n    ISBN VARCHAR(20) UNIQUE NOT NULL,\n    Titel VARCHAR(200) NOT NULL,\n    Autor VARCHAR(100),\n    Verlag_ID INT,\n    FOREIGN KEY (Verlag_ID) REFERENCES Verlage(Verlag_ID)\n);\n\n-- Leser (separate Tabelle)\nCREATE TABLE Leser (\n    Leser_ID INT PRIMARY KEY AUTO_INCREMENT,\n    Name VARCHAR(100) NOT NULL,\n    Email VARCHAR(100) UNIQUE\n);\n\n-- Ausleihen (nur Referenzen)\nCREATE TABLE Ausleihen (\n    Ausleihe_ID INT PRIMARY KEY AUTO_INCREMENT,\n    Buch_ID INT NOT NULL,\n    Leser_ID INT NOT NULL,\n    Ausleihdatum DATE NOT NULL DEFAULT CURRENT_DATE,\n    Rückgabedatum DATE,\n    FOREIGN KEY (Buch_ID) REFERENCES Buecher(Buch_ID),\n    FOREIGN KEY (Leser_ID) REFERENCES Leser(Leser_ID)\n);\n\n-- Vorteile der normalisierten Struktur:\n\n-- 1. Buch hinzufügen ohne Ausleihe (Einfüge-Anomalie behoben)\nINSERT INTO Verlage (Verlag_Name, Adresse) VALUES ('Springer', 'Berlin');\nINSERT INTO Buecher (ISBN, Titel, Autor, Verlag_ID) \nVALUES ('978-3-16-148410-0', 'Datenbanken Grundlagen', 'Dr. Schmidt', 1);\n-- ✅ Buch existiert, auch ohne Ausleihe!\n\n-- 2. Verlagsadresse ändern (Änderungs-Anomalie behoben)\nUPDATE Verlage SET Adresse = 'München' WHERE Verlag_ID = 1;\n-- ✅ Nur eine Zeile ändern, betrifft alle Bücher des Verlags!\n\n-- 3. Ausleihe löschen (Lösch-Anomalie behoben)\nDELETE FROM Ausleihen WHERE Ausleihe_ID = 1;\n-- ✅ Buch- und Leser-Daten bleiben erhalten!\n\n-- Query mit JOINs (Nachteil der Normalisierung)\nSELECT \n    a.Ausleihe_ID,\n    b.Titel,\n    b.Autor,\n    v.Verlag_Name,\n    l.Name AS Leser_Name,\n    a.Ausleihdatum,\n    a.Rückgabedatum\nFROM Ausleihen a\nJOIN Buecher b ON a.Buch_ID = b.Buch_ID\nJOIN Verlage v ON b.Verlag_ID = v.Verlag_ID\nJOIN Leser l ON a.Leser_ID = l.Leser_ID\nWHERE a.Rückgabedatum IS NULL;  -- Aktuell ausgeliehene Bücher",
      "explanation": "Realistisches Beispiel eines Bibliothekssystems. Zeigt Problemanalyse und vollständige Normalisierung mit praktischen Queries."
    }
  ],
  "relatedQuizzes": ["fue-02-anomalies-redundancies-quiz"],
  "resources": [
    {
      "title": "Database Normalization Explained",
      "url": "https://www.guru99.com/database-normalization.html",
      "type": "article"
    },
    {
      "title": "Normal Forms in DBMS",
      "url": "https://www.geeksforgeeks.org/normal-forms-in-dbms/",
      "type": "article"
    }
  ],
  "lastUpdated": "2025-01-05T10:00:00Z",
  "version": "1.0"
}
