{
  "id": "bp-05-data-structures",
  "title": "Datenstrukturen (Arrays, Listen, Stacks, Queues, Trees)",
  "description": "Grundlegende Datenstrukturen und ihre Anwendungsfälle",
  "category": "BP-05",
  "subcategory": "Algorithmen und Datenstrukturen",
  "difficulty": "intermediate",
  "examRelevance": "high",
  "newIn2025": false,
  "removedIn2025": false,
  "important": true,
  "estimatedTime": 60,
  "prerequisites": [],
  "tags": [
    "Datenstrukturen",
    "Arrays",
    "Listen",
    "Stack",
    "Queue",
    "Tree"
  ],
  "content": "# Datenstrukturen\n\n## Einführung\n\nDatenstrukturen sind Methoden zur Organisation und Speicherung von Daten, die effiziente Zugriffs- und Änderungsoperationen ermöglichen.\n\n<!-- micro-quiz:bp-05-data-structures-einfuhrung-micro-1 -->\n## Arrays\n\n### Eigenschaften\n\n- **Feste Größe**: Größe bei Erstellung festgelegt\n- **Zusammenhängender Speicher**: Elemente direkt hintereinander\n- **Index-basierter Zugriff**: O(1) Zugriff\n- **Homogen**: Alle Elemente gleichen Typs\n\n### Operationen\n\n```java\n// Array erstellen\nint[] numbers = new int[5];\nint[] values = {1, 2, 3, 4, 5};\n\n// Zugriff: O(1)\nint first = values[0];\n\n// Ändern: O(1)\nvalues[2] = 10;\n\n// Suchen: O(n)\nfor (int i = 0; i < values.length; i++) {\n    if (values[i] == 10) {\n        System.out.println(\"Found at index \" + i);\n    }\n}\n```\n\n### Vor- und Nachteile\n\n**Vorteile:**\n- Schneller Zugriff (O(1))\n- Geringer Speicher-Overhead\n- Cache-freundlich\n\n**Nachteile:**\n- Feste Größe\n- Einfügen/Löschen teuer (O(n))\n- Verschwendung bei nicht voller Nutzung\n\n## Listen\n<!-- micro-quiz:bp-05-data-structures-arrays-micro-1 -->\n\n\n### ArrayList (Dynamisches Array)\n\n```java\nimport java.util.ArrayList;\n\nArrayList<String> list = new ArrayList<>();\n\n// Hinzufügen: O(1) amortisiert\nlist.add(\"Apple\");\nlist.add(\"Banana\");\nlist.add(\"Cherry\");\n\n// Zugriff: O(1)\nString first = list.get(0);\n\n// Einfügen: O(n)\nlist.add(1, \"Apricot\");\n\n// Löschen: O(n)\nlist.remove(0);\n\n// Größe\nint size = list.size();\n```\n\n### LinkedList (Verkettete Liste)\n\n**Struktur:**\n```\n[Data|Next] -> [Data|Next] -> [Data|Next] -> null\n```\n\n```java\nimport java.util.LinkedList;\n\nLinkedList<String> list = new LinkedList<>();\n\n// Hinzufügen: O(1) am Anfang/Ende\nlist.addFirst(\"First\");\nlist.addLast(\"Last\");\n\n// Zugriff: O(n)\nString element = list.get(2);\n\n// Einfügen: O(1) wenn Position bekannt\nlist.add(1, \"Middle\");\n\n// Löschen: O(1) wenn Position bekannt\nlist.removeFirst();\nlist.removeLast();\n```\n\n### ArrayList vs. LinkedList\n\n| Operation | ArrayList | LinkedList |\n|-----------|-----------|------------|\n| Zugriff | O(1) | O(n) |\n| Einfügen (Ende) | O(1)* | O(1) |\n| Einfügen (Mitte) | O(n) | O(1)** |\n| Löschen | O(n) | O(1)** |\n| Speicher | Weniger | Mehr (Pointer) |\n\n*amortisiert, **wenn Position bekannt\n\n<!-- micro-quiz:bp-05-data-structures-listen-micro-1 -->\n## Stack (Stapel)\n\n### Eigenschaften\n\n- **LIFO**: Last In, First Out\n- **Push**: Element oben hinzufügen\n- **Pop**: Element oben entfernen\n- **Peek**: Oberstes Element ansehen\n\n### Implementierung\n\n```java\nimport java.util.Stack;\n\nStack<Integer> stack = new Stack<>();\n\n// Push: O(1)\nstack.push(1);\nstack.push(2);\nstack.push(3);\n\n// Peek: O(1)\nint top = stack.peek();  // 3\n\n// Pop: O(1)\nint removed = stack.pop();  // 3\n\n// Leer?\nboolean empty = stack.isEmpty();\n\n// Größe\nint size = stack.size();\n```\n\n### Anwendungsfälle\n\n- **Funktionsaufrufe**: Call Stack\n- **Undo/Redo**: Aktionen rückgängig machen\n- **Klammerprüfung**: Syntaxvalidierung\n- **Tiefensuche (DFS)**: Graph-Traversierung\n\n### Beispiel: Klammerprüfung\n\n```java\npublic boolean isValidParentheses(String s) {\n    Stack<Character> stack = new Stack<>();\n    \n    for (char c : s.toCharArray()) {\n        if (c == '(' || c == '[' || c == '{') {\n            stack.push(c);\n        } else {\n            if (stack.isEmpty()) return false;\n            \n            char top = stack.pop();\n            if (c == ')' && top != '(') return false;\n            if (c == ']' && top != '[') return false;\n            if (c == '}' && top != '{') return false;\n        }\n    }\n    \n    return stack.isEmpty();\n}\n\n// Test\nisValidParentheses(\"({[]})\");  // true\nisValidParentheses(\"({[})\");   // false\n```\n\n## Queue (Warteschlange)\n<!-- micro-quiz:bp-05-data-structures-stack-stapel-micro-1 -->\n\n\n### Eigenschaften\n\n- **FIFO**: First In, First Out\n- **Enqueue**: Element hinten hinzufügen\n- **Dequeue**: Element vorne entfernen\n- **Peek**: Vorderstes Element ansehen\n\n### Implementierung\n\n```java\nimport java.util.Queue;\nimport java.util.LinkedList;\n\nQueue<String> queue = new LinkedList<>();\n\n// Enqueue: O(1)\nqueue.offer(\"First\");\nqueue.offer(\"Second\");\nqueue.offer(\"Third\");\n\n// Peek: O(1)\nString front = queue.peek();  // \"First\"\n\n// Dequeue: O(1)\nString removed = queue.poll();  // \"First\"\n\n// Leer?\nboolean empty = queue.isEmpty();\n\n// Größe\nint size = queue.size();\n```\n\n### Anwendungsfälle\n\n- **Task-Scheduling**: Aufgabenwarteschlange\n- **Breadth-First Search (BFS)**: Graph-Traversierung\n- **Printer Queue**: Druckaufträge\n- **Message Queue**: Nachrichtenverarbeitung\n\n### Priority Queue\n\n```java\nimport java.util.PriorityQueue;\n\nPriorityQueue<Integer> pq = new PriorityQueue<>();\n\n// Hinzufügen: O(log n)\npq.offer(5);\npq.offer(1);\npq.offer(3);\n\n// Peek: O(1) - kleinstes Element\nint min = pq.peek();  // 1\n\n// Poll: O(log n)\nint removed = pq.poll();  // 1\n```\n\n<!-- micro-quiz:bp-05-data-structures-queue-warteschlange-micro-1 -->\n## Trees (Bäume)\n\n### Binary Tree (Binärbaum)\n\n**Struktur:**\n```\n       10\n      /  \\\n     5    15\n    / \\   / \\\n   3   7 12  20\n```\n\n**Eigenschaften:**\n- Jeder Knoten hat maximal 2 Kinder\n- Root: Wurzelknoten\n- Leaf: Blattknoten (keine Kinder)\n- Height: Höhe des Baums\n\n### Binary Search Tree (BST)\n\n**Eigenschaften:**\n- Linkes Kind < Parent\n- Rechtes Kind > Parent\n- Effiziente Suche: O(log n) im Durchschnitt\n\n```java\nclass TreeNode {\n    int value;\n    TreeNode left;\n    TreeNode right;\n    \n    TreeNode(int value) {\n        this.value = value;\n    }\n}\n\nclass BinarySearchTree {\n    TreeNode root;\n    \n    // Einfügen: O(log n) durchschnittlich\n    public void insert(int value) {\n        root = insertRec(root, value);\n    }\n    \n    private TreeNode insertRec(TreeNode node, int value) {\n        if (node == null) {\n            return new TreeNode(value);\n        }\n        \n        if (value < node.value) {\n            node.left = insertRec(node.left, value);\n        } else if (value > node.value) {\n            node.right = insertRec(node.right, value);\n        }\n        \n        return node;\n    }\n    \n    // Suchen: O(log n) durchschnittlich\n    public boolean search(int value) {\n        return searchRec(root, value);\n    }\n    \n    private boolean searchRec(TreeNode node, int value) {\n        if (node == null) return false;\n        if (node.value == value) return true;\n        \n        if (value < node.value) {\n            return searchRec(node.left, value);\n        } else {\n            return searchRec(node.right, value);\n        }\n    }\n}\n```\n\n### Tree Traversal (Baumtraversierung)\n\n**Inorder (Links-Wurzel-Rechts):**\n```java\nvoid inorder(TreeNode node) {\n    if (node == null) return;\n    inorder(node.left);\n    System.out.print(node.value + \" \");\n    inorder(node.right);\n}\n// Output für BST: 3 5 7 10 12 15 20 (sortiert!)\n```\n\n**Preorder (Wurzel-Links-Rechts):**\n```java\nvoid preorder(TreeNode node) {\n    if (node == null) return;\n    System.out.print(node.value + \" \");\n    preorder(node.left);\n    preorder(node.right);\n}\n// Output: 10 5 3 7 15 12 20\n```\n\n**Postorder (Links-Rechts-Wurzel):**\n```java\nvoid postorder(TreeNode node) {\n    if (node == null) return;\n    postorder(node.left);\n    postorder(node.right);\n    System.out.print(node.value + \" \");\n}\n// Output: 3 7 5 12 20 15 10\n```\n\n**Level-Order (Breitensuche):**\n```java\nvoid levelOrder(TreeNode root) {\n    if (root == null) return;\n    \n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.offer(root);\n    \n    while (!queue.isEmpty()) {\n        TreeNode node = queue.poll();\n        System.out.print(node.value + \" \");\n        \n        if (node.left != null) queue.offer(node.left);\n        if (node.right != null) queue.offer(node.right);\n    }\n}\n// Output: 10 5 15 3 7 12 20\n```\n\n## Hash Table (Hash Map)\n<!-- micro-quiz:bp-05-data-structures-trees-baume-micro-1 -->\n\n\n### Eigenschaften\n\n- **Key-Value-Paare**: Zuordnung von Schlüsseln zu Werten\n- **Hash-Funktion**: Berechnet Index aus Schlüssel\n- **Durchschnittlich O(1)**: Für Einfügen, Suchen, Löschen\n\n```java\nimport java.util.HashMap;\n\nHashMap<String, Integer> map = new HashMap<>();\n\n// Einfügen: O(1) durchschnittlich\nmap.put(\"Alice\", 25);\nmap.put(\"Bob\", 30);\nmap.put(\"Charlie\", 35);\n\n// Zugriff: O(1) durchschnittlich\nint age = map.get(\"Alice\");  // 25\n\n// Enthält Schlüssel?\nboolean hasKey = map.containsKey(\"Bob\");  // true\n\n// Löschen: O(1) durchschnittlich\nmap.remove(\"Charlie\");\n\n// Iterieren\nfor (String key : map.keySet()) {\n    System.out.println(key + \": \" + map.get(key));\n}\n```\n\n<!-- micro-quiz:bp-05-data-structures-hash-table-hash-map-micro-1 -->\n## Komplexitätsvergleich\n\n| Datenstruktur | Zugriff | Suchen | Einfügen | Löschen |\n|---------------|---------|--------|----------|----------|\n| Array | O(1) | O(n) | O(n) | O(n) |\n| ArrayList | O(1) | O(n) | O(n) | O(n) |\n| LinkedList | O(n) | O(n) | O(1)* | O(1)* |\n| Stack | O(n) | O(n) | O(1) | O(1) |\n| Queue | O(n) | O(n) | O(1) | O(1) |\n| BST | O(log n) | O(log n) | O(log n) | O(log n) |\n| Hash Table | - | O(1)** | O(1)** | O(1)** |\n\n*wenn Position bekannt, **durchschnittlich\n\n## Prüfungsrelevante Aspekte\n<!-- micro-quiz:bp-05-data-structures-komplexitatsvergleich-micro-1 -->\n\n\n- Datenstrukturen und ihre Eigenschaften kennen\n- Zeitkomplexität von Operationen verstehen\n- Anwendungsfälle zuordnen\n- Stack vs. Queue unterscheiden\n- Tree-Traversierung verstehen\n- Vor- und Nachteile benennen\n\n\n<!-- micro-quiz:bp-05-data-structures-prufungsrelevante-aspekte-micro-1 -->",
  "codeExamples": [
    {
      "language": "java",
      "code": "// Praktisches Beispiel: LRU Cache mit LinkedHashMap\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\nclass LRUCache<K, V> extends LinkedHashMap<K, V> {\n    private final int capacity;\n    \n    public LRUCache(int capacity) {\n        super(capacity, 0.75f, true);  // accessOrder = true\n        this.capacity = capacity;\n    }\n    \n    @Override\n    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {\n        return size() > capacity;\n    }\n}\n\n// Verwendung\nLRUCache<String, Integer> cache = new LRUCache<>(3);\ncache.put(\"A\", 1);\ncache.put(\"B\", 2);\ncache.put(\"C\", 3);\ncache.get(\"A\");  // A wird \"recent\"\ncache.put(\"D\", 4);  // B wird entfernt (least recently used)\n\nSystem.out.println(cache);  // {C=3, A=1, D=4}",
      "explanation": "LRU Cache kombiniert HashMap und LinkedList für effiziente Cache-Verwaltung",
      "title": "LRU Cache Implementierung"
    }
  ],
  "relatedQuizzes": [],
  "resources": [
    {
      "title": "Java Collections Framework",
      "url": "https://docs.oracle.com/javase/8/docs/technotes/guides/collections/",
      "type": "documentation"
    }
  ],
  "lastUpdated": "2025-01-10T00:00:00Z",
  "version": "1.0",
  "learningObjectives": [
    "Du kannst datenstrukturen erklären",
    "Du kannst arrays erklären",
    "Du kannst listen erklären",
    "Du kannst stack erklären",
    "Du kannst queue erklären"
  ],
  "summary": "Grundlegende Datenstrukturen und ihre Anwendungsfälle",
  "contentOutline": [
    {
      "id": "datenstrukturen",
      "title": "Datenstrukturen",
      "summary": "Kernaspekt: Datenstrukturen"
    },
    {
      "id": "einfuhrung",
      "title": "Einführung",
      "summary": "Kernaspekt: Einführung"
    },
    {
      "id": "arrays",
      "title": "Arrays",
      "summary": "Kernaspekt: Arrays"
    },
    {
      "id": "listen",
      "title": "Listen",
      "summary": "Kernaspekt: Listen"
    },
    {
      "id": "stack-stapel",
      "title": "Stack (Stapel)",
      "summary": "Kernaspekt: Stack (Stapel)"
    },
    {
      "id": "queue-warteschlange",
      "title": "Queue (Warteschlange)",
      "summary": "Kernaspekt: Queue (Warteschlange)"
    },
    {
      "id": "trees-baume",
      "title": "Trees (Bäume)",
      "summary": "Kernaspekt: Trees (Bäume)"
    },
    {
      "id": "hash-table-hash-map",
      "title": "Hash Table (Hash Map)",
      "summary": "Kernaspekt: Hash Table (Hash Map)"
    },
    {
      "id": "komplexitatsvergleich",
      "title": "Komplexitätsvergleich",
      "summary": "Kernaspekt: Komplexitätsvergleich"
    },
    {
      "id": "prufungsrelevante-aspekte",
      "title": "Prüfungsrelevante Aspekte",
      "summary": "Kernaspekt: Prüfungsrelevante Aspekte"
    }
  ],
  "accessibilityNotes": "Klare Überschriften, kurze Sätze, keine reine Farb-Codierung.",
  "editorNote": "Automatisch ergänzt: Review erforderlich",
  "microQuizFocus": {
    "bp-05-data-structures-einfuhrung-micro-1": {
      "contentOutlineId": "einfuhrung",
      "learningObjective": "Du kannst datenstrukturen erklären",
      "contextCues": [
        "Verankere die Einstiegsfrage in einer Entscheidung zwischen Array, Liste und Map für Sensordaten.",
        "Betone Prüfungszeitdruck: kurze Definition plus Nutzen muss in unter 30 Sekunden beantwortbar sein."
      ],
      "questionBlueprint": {
        "recommendedTypes": [
          "scenario-single-choice"
        ],
        "rationaleFocus": "Zeige den Zusammenhang zwischen Begriffserklärung und Auswahl einer geeigneten Struktur in einem Praxisprojekt.",
        "misconceptions": [
          "Alle Datenstrukturen seien nur Syntaxvarianten ohne Einfluss auf Performance."
        ]
      },
      "evidence": [
        "Requirement 7: Begrenzung auf fünf Fragen mit Feedback erst nach Abgabe."
      ]
    },
    "bp-05-data-structures-arrays-micro-1": {
      "contentOutlineId": "arrays",
      "learningObjective": "Du kannst arrays erklären",
      "contextCues": [
        "Frage rahmen, warum ein Array für zyklische Messwerte mit fixer Länge gewählt wird.",
        "Hinweis auf Grenzwertfälle bei Indexzugriff und Off-by-one-Fehler."
      ],
      "questionBlueprint": {
        "recommendedTypes": [
          "code-output",
          "scenario-multi-select"
        ],
        "rationaleFocus": "Erkläre, wie Speicherlayout und Indexierung direkte Auswirkungen auf Laufzeit und Fehleranfälligkeit haben.",
        "misconceptions": [
          "Arrays wachsen automatisch ohne Kopieroperation",
          "Indexzählung beginnt bei 1 in allen Sprachen"
        ]
      },
      "evidence": [
        "Codebeispiel im Modulabschnitt Arrays",
        "AssessmentService: Teilpunkte bei Multi-Select berücksichtigen"
      ]
    },
    "bp-05-data-structures-listen-micro-1": {
      "contentOutlineId": "listen",
      "learningObjective": "Du kannst listen erklären",
      "contextCues": [
        "Vergleiche dynamische Arrays mit verketteten Listen anhand von Insert-Operationen.",
        "Verweise auf Speicher-Overhead vs. konstante Zeit bei Einfügen am Listenanfang."
      ],
      "questionBlueprint": {
        "recommendedTypes": [
          "scenario-single-choice"
        ],
        "rationaleFocus": "Führe die Lernenden zu einer Entscheidung über die geeignete Struktur für eine Warteschlange oder History-Liste.",
        "misconceptions": [
          "Linked Lists seien immer schneller als Arrays",
          "ArrayList und LinkedList hätten identische Einfügekomplexität"
        ]
      },
      "evidence": [
        "Tabellarischer Vergleich ArrayList vs. LinkedList im Abschnitt Listen"
      ]
    },
    "bp-05-data-structures-queue-warteschlange-micro-1": {
      "contentOutlineId": "queue-warteschlange",
      "learningObjective": "Du kannst queue erklären",
      "contextCues": [
        "Setze das Szenario eines Drucker-Spools oder Message-Queues ein, um FIFO zu verdeutlichen.",
        "Hebe Retry-Strategien und Rate-Limiting als Brücke zu REST-API-Modulen hervor."
      ],
      "questionBlueprint": {
        "recommendedTypes": [
          "scenario-single-choice",
          "sequence-order"
        ],
        "rationaleFocus": "Lenke den Fokus auf Auswirkungen falscher FIFO-Umsetzungen auf Benutzererlebnis und Prüfungsaufgaben.",
        "misconceptions": [
          "Queues seien dasselbe wie Stacks",
          "Alle Queue-Operationen seien O(1) auch bei ungeeigneter Implementierung"
        ]
      },
      "evidence": [
        "Anwendungsfälle im Abschnitt Queue",
        "Requirement 7: Teilpunkte für mehrteilige Szenarien"
      ]
    }
  },
  "microQuizzes": [
    "bp-05-data-structures-einfuhrung-micro-1",
    "bp-05-data-structures-arrays-micro-1",
    "bp-05-data-structures-listen-micro-1",
    "bp-05-data-structures-stack-stapel-micro-1",
    "bp-05-data-structures-queue-warteschlange-micro-1",
    "bp-05-data-structures-trees-baume-micro-1",
    "bp-05-data-structures-hash-table-hash-map-micro-1",
    "bp-05-data-structures-komplexitatsvergleich-micro-1",
    "bp-05-data-structures-prufungsrelevante-aspekte-micro-1"
  ]
}
