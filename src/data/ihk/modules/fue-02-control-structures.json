{
  "id": "fue-02-control-structures",
  "title": "Kontrollstrukturen: Aktivitätsdiagramme und Pseudocode",
  "description": "Lerne moderne Methoden zur Darstellung von Kontrollstrukturen mit Aktivitätsdiagrammen und Pseudocode. Struktogramme und PAP sind veraltet.",
  "category": "FÜ-02",
  "subcategory": "Entwickeln und Bereitstellen von Softwareanwendungen - Algorithmen",
  "difficulty": "beginner",
  "examRelevance": "high",
  "newIn2025": true,
  "removedIn2025": false,
  "important": true,
  "estimatedTime": 45,
  "prerequisites": [],
  "tags": [
    "kontrollstrukturen",
    "aktivitätsdiagramm",
    "pseudocode",
    "algorithmen",
    "uml",
    "sequenz",
    "verzweigung",
    "schleife"
  ],
  "content": "# Kontrollstrukturen: Aktivitätsdiagramme und Pseudocode\n\n## Übersicht\n\n**Kontrollstrukturen** steuern den Ablauf eines Programms. Zur Darstellung von Algorithmen werden in der IHK-Prüfung ab 2025 **Aktivitätsdiagramme** (UML) und **Pseudocode** verwendet.\n\n### ⚠️ Wichtige Änderung ab 2025\n\n**VERALTET (nicht mehr prüfungsrelevant):**\n- ❌ Struktogramme (Nassi-Shneiderman-Diagramme)\n- ❌ Programmablaufpläne (PAP/Flussdiagramme)\n\n**NEU (prüfungsrelevant ab 2025):**\n- ✅ Aktivitätsdiagramme (UML)\n- ✅ Pseudocode\n\n## Die drei Grundstrukturen\n\nJeder Algorithmus besteht aus drei Grundstrukturen:\n\n1. **Sequenz**: Befehle werden nacheinander ausgeführt\n2. **Verzweigung (Selektion)**: Bedingte Ausführung\n3. **Wiederholung (Iteration)**: Schleifen\n\n## Aktivitätsdiagramme (UML)\n\n**Aktivitätsdiagramme** sind Teil der UML (Unified Modeling Language) und zeigen den Ablauf von Aktivitäten.\n\n### Grundelemente\n\n```\n● Startknoten (gefüllter Kreis)\n↓\n┌─────────────────┐\n│   Aktivität     │  Rechteck mit abgerundeten Ecken\n└─────────────────┘\n↓\n◆ Entscheidungsknoten (Raute)\n↓\n◉ Endknoten (gefüllter Kreis mit Ring)\n```\n\n### 1. Sequenz (Nacheinander)\n\n**Aktivitätsdiagramm:**\n```\n●\n↓\n┌─────────────────┐\n│ Wasser kochen   │\n└─────────────────┘\n↓\n┌─────────────────┐\n│ Tee aufgießen   │\n└─────────────────┘\n↓\n┌─────────────────┐\n│ 5 Min ziehen    │\n└─────────────────┘\n↓\n◉\n```\n\n**Pseudocode:**\n```\nBEGIN\n    Wasser kochen\n    Tee aufgießen\n    5 Minuten ziehen lassen\nEND\n```\n\n**Java-Code:**\n```java\npublic void teeMachen() {\n    wasserKochen();\n    teeAufgiessen();\n    warten(5);\n}\n```\n\n### 2. Verzweigung (If-Then-Else)\n\n**Aktivitätsdiagramm:**\n```\n●\n↓\n┌─────────────────┐\n│ Temperatur      │\n│ messen          │\n└─────────────────┘\n↓\n      ◆ [Temp > 30°C?]\n     / \\\n[ja]/   \\[nein]\n   /     \\\n  ↓       ↓\n┌────┐  ┌────┐\n│Klima│  │Heiz│\n│an   │  │ung │\n│     │  │an  │\n└────┘  └────┘\n  ↓       ↓\n   \\     /\n    \\   /\n     ↓ ↓\n      ●\n     ↓\n     ◉\n```\n\n**Pseudocode:**\n```\nBEGIN\n    temperatur = messe_temperatur()\n    \n    IF temperatur > 30 THEN\n        klimaanlage_einschalten()\n    ELSE\n        heizung_einschalten()\n    END IF\nEND\n```\n\n**Java-Code:**\n```java\npublic void temperaturRegeln() {\n    double temperatur = messeTemperatur();\n    \n    if (temperatur > 30) {\n        klimaanlageEinschalten();\n    } else {\n        heizungEinschalten();\n    }\n}\n```\n\n### 3. Mehrfachverzweigung (Switch/Case)\n\n**Aktivitätsdiagramm:**\n```\n●\n↓\n┌─────────────────┐\n│ Wochentag       │\n│ ermitteln       │\n└─────────────────┘\n↓\n      ◆ [Wochentag?]\n     /│\\\\\n    / │ \\ \\\n[Mo][Di][Mi][...]\n  ↓  ↓  ↓   ↓\n┌──┐┌──┐┌──┐┌──┐\n│A1││A2││A3││A4│\n└──┘└──┘└──┘└──┘\n  ↓  ↓  ↓   ↓\n   \\ │ /   /\n    \\│/   /\n     ●   /\n      \\ /\n       ◉\n```\n\n**Pseudocode:**\n```\nBEGIN\n    tag = ermittle_wochentag()\n    \n    SWITCH tag\n        CASE \"Montag\":\n            aktion_montag()\n        CASE \"Dienstag\":\n            aktion_dienstag()\n        CASE \"Mittwoch\":\n            aktion_mittwoch()\n        DEFAULT:\n            aktion_standard()\n    END SWITCH\nEND\n```\n\n**Java-Code:**\n```java\npublic void wochentagAktion(String tag) {\n    switch (tag) {\n        case \"Montag\":\n            aktionMontag();\n            break;\n        case \"Dienstag\":\n            aktionDienstag();\n            break;\n        case \"Mittwoch\":\n            aktionMittwoch();\n            break;\n        default:\n            aktionStandard();\n    }\n}\n```\n\n### 4. Wiederholung - While-Schleife (kopfgesteuert)\n\n**Aktivitätsdiagramm:**\n```\n●\n↓\n┌─────────────────┐\n│ counter = 0     │\n└─────────────────┘\n↓\n◆ [counter < 10?]\n│ [nein] → ◉\n│\n│[ja]\n↓\n┌─────────────────┐\n│ Aktion          │\n│ ausführen       │\n└─────────────────┘\n↓\n┌─────────────────┐\n│ counter = counter│\n│ + 1             │\n└─────────────────┘\n↓\n│\n└──→ zurück zu ◆\n```\n\n**Pseudocode:**\n```\nBEGIN\n    counter = 0\n    \n    WHILE counter < 10 DO\n        aktion_ausfuehren()\n        counter = counter + 1\n    END WHILE\nEND\n```\n\n**Java-Code:**\n```java\npublic void whileBeispiel() {\n    int counter = 0;\n    \n    while (counter < 10) {\n        aktionAusfuehren();\n        counter++;\n    }\n}\n```\n\n### 5. Wiederholung - Do-While-Schleife (fußgesteuert)\n\n**Aktivitätsdiagramm:**\n```\n●\n↓\n┌─────────────────┐\n│ counter = 0     │\n└─────────────────┘\n↓\n┌─────────────────┐\n│ Aktion          │ ← Wird mindestens 1x ausgeführt!\n│ ausführen       │\n└─────────────────┘\n↓\n┌─────────────────┐\n│ counter = counter│\n│ + 1             │\n└─────────────────┘\n↓\n◆ [counter < 10?]\n│ [nein] → ◉\n│\n│[ja]\n└──→ zurück zu \"Aktion ausführen\"\n```\n\n**Pseudocode:**\n```\nBEGIN\n    counter = 0\n    \n    DO\n        aktion_ausfuehren()\n        counter = counter + 1\n    WHILE counter < 10\nEND\n```\n\n**Java-Code:**\n```java\npublic void doWhileBeispiel() {\n    int counter = 0;\n    \n    do {\n        aktionAusfuehren();\n        counter++;\n    } while (counter < 10);\n}\n```\n\n### 6. Wiederholung - For-Schleife (Zählschleife)\n\n**Aktivitätsdiagramm:**\n```\n●\n↓\n┌─────────────────┐\n│ i = 0           │\n└─────────────────┘\n↓\n◆ [i < 10?]\n│ [nein] → ◉\n│\n│[ja]\n↓\n┌─────────────────┐\n│ Aktion mit i    │\n└─────────────────┘\n↓\n┌─────────────────┐\n│ i = i + 1       │\n└─────────────────┘\n↓\n│\n└──→ zurück zu ◆\n```\n\n**Pseudocode:**\n```\nBEGIN\n    FOR i = 0 TO 9 DO\n        aktion_mit(i)\n    END FOR\nEND\n```\n\n**Java-Code:**\n```java\npublic void forBeispiel() {\n    for (int i = 0; i < 10; i++) {\n        aktionMit(i);\n    }\n}\n```\n\n## Pseudocode-Konventionen\n\n### Grundregeln\n\n1. **Lesbar**: Verständlich für Menschen, nicht für Computer\n2. **Strukturiert**: Einrückungen zeigen Hierarchie\n3. **Sprachunabhängig**: Keine spezifische Programmiersprache\n4. **Schlüsselwörter**: GROSSBUCHSTABEN (BEGIN, END, IF, WHILE, etc.)\n\n### Häufige Schlüsselwörter\n\n```\nBEGIN / END          - Programmblock\nIF / THEN / ELSE     - Verzweigung\nWHILE / DO           - Schleife\nFOR / TO / DO        - Zählschleife\nREPEAT / UNTIL       - Do-While-Schleife\nSWITCH / CASE        - Mehrfachverzweigung\nFUNCTION / RETURN    - Funktion\nINPUT / OUTPUT       - Ein-/Ausgabe\nAND / OR / NOT       - Logische Operatoren\n```\n\n### Beispiel: Komplexer Algorithmus\n\n**Aufgabe**: Finde das Maximum in einem Array\n\n**Pseudocode:**\n```\nFUNCTION finde_maximum(array)\nBEGIN\n    IF array ist leer THEN\n        RETURN null\n    END IF\n    \n    maximum = array[0]\n    \n    FOR i = 1 TO länge(array) - 1 DO\n        IF array[i] > maximum THEN\n            maximum = array[i]\n        END IF\n    END FOR\n    \n    RETURN maximum\nEND\n```\n\n**Aktivitätsdiagramm:**\n```\n●\n↓\n◆ [Array leer?]\n│ [ja] → RETURN null → ◉\n│\n│[nein]\n↓\n┌─────────────────┐\n│ max = array[0]  │\n│ i = 1           │\n└─────────────────┘\n↓\n◆ [i < länge?]\n│ [nein] → RETURN max → ◉\n│\n│[ja]\n↓\n◆ [array[i] > max?]\n│ [nein] → i++\n│           ↓\n│           └──→ zurück zu [i < länge?]\n│\n│[ja]\n↓\n┌─────────────────┐\n│ max = array[i]  │\n└─────────────────┘\n↓\n┌─────────────────┐\n│ i = i + 1       │\n└─────────────────┘\n↓\n└──→ zurück zu [i < länge?]\n```\n\n**Java-Code:**\n```java\npublic Integer findeMaximum(int[] array) {\n    if (array == null || array.length == 0) {\n        return null;\n    }\n    \n    int maximum = array[0];\n    \n    for (int i = 1; i < array.length; i++) {\n        if (array[i] > maximum) {\n            maximum = array[i];\n        }\n    }\n    \n    return maximum;\n}\n```\n\n## Vergleich: Aktivitätsdiagramm vs. Pseudocode\n\n| Merkmal | Aktivitätsdiagramm | Pseudocode |\n|---------|-------------------|------------|\n| **Visualisierung** | Grafisch | Textuell |\n| **Übersichtlichkeit** | Gut bei einfachen Abläufen | Gut bei komplexen Algorithmen |\n| **Detailgrad** | Mittel | Hoch |\n| **Erstellung** | Zeitaufwändig | Schnell |\n| **Standardisierung** | UML-Standard | Keine feste Norm |\n| **Verwendung** | Prozessmodellierung | Algorithmen-Design |\n\n## Warum Struktogramme und PAP veraltet sind\n\n### Struktogramme (Nassi-Shneiderman)\n\n**Nachteile:**\n- ❌ Nicht standardisiert (kein UML)\n- ❌ Schwer zu zeichnen und zu ändern\n- ❌ Unübersichtlich bei komplexen Algorithmen\n- ❌ Kaum noch in der Praxis verwendet\n\n### Programmablaufpläne (PAP)\n\n**Nachteile:**\n- ❌ Veraltet (aus den 1960er Jahren)\n- ❌ Zu detailliert für moderne Entwicklung\n- ❌ Unflexibel bei Änderungen\n- ❌ Aktivitätsdiagramme sind moderner und flexibler\n\n### Moderne Alternativen\n\n✅ **Aktivitätsdiagramme**: UML-Standard, weit verbreitet\n✅ **Pseudocode**: Schnell, flexibel, sprachunabhängig\n✅ **Sequenzdiagramme**: Für Interaktionen zwischen Objekten\n✅ **Zustandsdiagramme**: Für zustandsbasierte Systeme\n\n## Praktische Beispiele\n\n### Beispiel 1: Login-Prozess\n\n**Pseudocode:**\n```\nFUNCTION login(username, password)\nBEGIN\n    versuche = 0\n    max_versuche = 3\n    \n    WHILE versuche < max_versuche DO\n        IF pruefeCredentials(username, password) THEN\n            RETURN \"Login erfolgreich\"\n        ELSE\n            versuche = versuche + 1\n            OUTPUT \"Falsches Passwort. Versuch \" + versuche + \" von \" + max_versuche\n        END IF\n    END WHILE\n    \n    RETURN \"Account gesperrt\"\nEND\n```\n\n### Beispiel 2: Bubble Sort\n\n**Pseudocode:**\n```\nFUNCTION bubble_sort(array)\nBEGIN\n    n = länge(array)\n    \n    FOR i = 0 TO n - 1 DO\n        FOR j = 0 TO n - i - 2 DO\n            IF array[j] > array[j + 1] THEN\n                // Tauschen\n                temp = array[j]\n                array[j] = array[j + 1]\n                array[j + 1] = temp\n            END IF\n        END FOR\n    END FOR\n    \n    RETURN array\nEND\n```\n\n### Beispiel 3: Fakultät berechnen\n\n**Pseudocode (iterativ):**\n```\nFUNCTION fakultaet(n)\nBEGIN\n    IF n < 0 THEN\n        RETURN \"Fehler: Negative Zahl\"\n    END IF\n    \n    ergebnis = 1\n    \n    FOR i = 1 TO n DO\n        ergebnis = ergebnis * i\n    END FOR\n    \n    RETURN ergebnis\nEND\n```\n\n**Pseudocode (rekursiv):**\n```\nFUNCTION fakultaet_rekursiv(n)\nBEGIN\n    IF n < 0 THEN\n        RETURN \"Fehler: Negative Zahl\"\n    END IF\n    \n    IF n == 0 OR n == 1 THEN\n        RETURN 1\n    ELSE\n        RETURN n * fakultaet_rekursiv(n - 1)\n    END IF\nEND\n```\n\n## Best Practices\n\n### Aktivitätsdiagramme\n\n1. **Klar strukturieren**: Von oben nach unten\n2. **Beschriftungen**: Bedingungen klar formulieren\n3. **Nicht zu detailliert**: Fokus auf Ablauf, nicht Implementation\n4. **Parallelität**: Nutze Fork/Join für parallele Aktivitäten\n\n### Pseudocode\n\n1. **Konsistent**: Einheitliche Schlüsselwörter\n2. **Einrückung**: Zeigt Struktur und Hierarchie\n3. **Kommentare**: Erkläre komplexe Logik\n4. **Verständlich**: Für andere lesbar\n5. **Sprachunabhängig**: Keine spezifische Syntax\n\n## Zusammenfassung\n\n### Prüfungsrelevant ab 2025\n\n✅ **Aktivitätsdiagramme (UML)**:\n- Grafische Darstellung von Abläufen\n- Standardisiert (UML)\n- Gut für Prozessmodellierung\n\n✅ **Pseudocode**:\n- Textuelle Darstellung von Algorithmen\n- Sprachunabhängig\n- Schnell und flexibel\n\n### Nicht mehr prüfungsrelevant\n\n❌ **Struktogramme**: Veraltet, nicht standardisiert\n❌ **PAP (Programmablaufpläne)**: Veraltet, zu detailliert\n\n### Für die IHK-Prüfung wichtig:\n\n- Verstehe die drei Grundstrukturen (Sequenz, Verzweigung, Schleife)\n- Kenne die Symbole von Aktivitätsdiagrammen\n- Schreibe verständlichen Pseudocode\n- Erkenne den Unterschied zwischen kopf- und fußgesteuerten Schleifen\n- Wisse, dass Struktogramme und PAP veraltet sind",
  "codeExamples": [
    {
      "language": "pseudocode",
      "title": "Pseudocode: Zahlenraten-Spiel",
      "code": "FUNCTION zahlenraten_spiel()\nBEGIN\n    zufallszahl = generiere_zufallszahl(1, 100)\n    versuche = 0\n    max_versuche = 7\n    gewonnen = false\n    \n    OUTPUT \"Errate die Zahl zwischen 1 und 100!\"\n    OUTPUT \"Du hast \" + max_versuche + \" Versuche.\"\n    \n    WHILE versuche < max_versuche AND NOT gewonnen DO\n        versuche = versuche + 1\n        OUTPUT \"Versuch \" + versuche + \": \"\n        eingabe = INPUT\n        \n        IF eingabe == zufallszahl THEN\n            gewonnen = true\n            OUTPUT \"Richtig! Du hast gewonnen in \" + versuche + \" Versuchen!\"\n        ELSE IF eingabe < zufallszahl THEN\n            OUTPUT \"Zu klein! Versuche eine größere Zahl.\"\n        ELSE\n            OUTPUT \"Zu groß! Versuche eine kleinere Zahl.\"\n        END IF\n    END WHILE\n    \n    IF NOT gewonnen THEN\n        OUTPUT \"Leider verloren! Die Zahl war: \" + zufallszahl\n    END IF\nEND",
      "explanation": "Vollständiges Zahlenraten-Spiel in Pseudocode. Zeigt Schleifen, Verzweigungen und Ein-/Ausgabe."
    },
    {
      "language": "java",
      "title": "Java: Primzahl-Prüfung",
      "code": "/**\n * Prüft, ob eine Zahl eine Primzahl ist\n * \n * Pseudocode:\n * FUNCTION ist_primzahl(n)\n * BEGIN\n *     IF n <= 1 THEN\n *         RETURN false\n *     END IF\n *     \n *     IF n == 2 THEN\n *         RETURN true\n *     END IF\n *     \n *     IF n MOD 2 == 0 THEN\n *         RETURN false\n *     END IF\n *     \n *     FOR i = 3 TO wurzel(n) STEP 2 DO\n *         IF n MOD i == 0 THEN\n *             RETURN false\n *         END IF\n *     END FOR\n *     \n *     RETURN true\n * END\n */\npublic class PrimzahlPruefer {\n    \n    public static boolean istPrimzahl(int n) {\n        // Zahlen <= 1 sind keine Primzahlen\n        if (n <= 1) {\n            return false;\n        }\n        \n        // 2 ist die einzige gerade Primzahl\n        if (n == 2) {\n            return true;\n        }\n        \n        // Alle anderen geraden Zahlen sind keine Primzahlen\n        if (n % 2 == 0) {\n            return false;\n        }\n        \n        // Prüfe ungerade Teiler bis zur Wurzel von n\n        int wurzel = (int) Math.sqrt(n);\n        for (int i = 3; i <= wurzel; i += 2) {\n            if (n % i == 0) {\n                return false;  // Teiler gefunden\n            }\n        }\n        \n        return true;  // Keine Teiler gefunden → Primzahl\n    }\n    \n    public static void main(String[] args) {\n        // Teste Primzahlen von 1 bis 50\n        System.out.println(\"Primzahlen von 1 bis 50:\");\n        \n        for (int i = 1; i <= 50; i++) {\n            if (istPrimzahl(i)) {\n                System.out.print(i + \" \");\n            }\n        }\n        // Ausgabe: 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47\n    }\n}",
      "explanation": "Primzahl-Prüfung mit Pseudocode-Kommentar und Java-Implementation. Zeigt optimierten Algorithmus."
    },
    {
      "language": "python",
      "title": "Python: Fibonacci-Folge",
      "code": "# Pseudocode:\n# FUNCTION fibonacci(n)\n# BEGIN\n#     IF n <= 0 THEN\n#         RETURN []\n#     ELSE IF n == 1 THEN\n#         RETURN [0]\n#     ELSE IF n == 2 THEN\n#         RETURN [0, 1]\n#     END IF\n#     \n#     folge = [0, 1]\n#     \n#     FOR i = 2 TO n - 1 DO\n#         naechste = folge[i-1] + folge[i-2]\n#         folge.append(naechste)\n#     END FOR\n#     \n#     RETURN folge\n# END\n\ndef fibonacci(n):\n    \"\"\"Generiert die ersten n Fibonacci-Zahlen\"\"\"\n    \n    # Spezialfälle\n    if n <= 0:\n        return []\n    elif n == 1:\n        return [0]\n    elif n == 2:\n        return [0, 1]\n    \n    # Initialisierung mit ersten zwei Zahlen\n    folge = [0, 1]\n    \n    # Generiere weitere Zahlen\n    for i in range(2, n):\n        naechste = folge[i-1] + folge[i-2]\n        folge.append(naechste)\n    \n    return folge\n\n# Verwendung\nif __name__ == \"__main__\":\n    # Erste 10 Fibonacci-Zahlen\n    ergebnis = fibonacci(10)\n    print(\"Fibonacci-Folge:\", ergebnis)\n    # Ausgabe: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    \n    # Summe der ersten 10 Fibonacci-Zahlen\n    summe = sum(ergebnis)\n    print(f\"Summe: {summe}\")  # 88",
      "explanation": "Fibonacci-Folge mit Pseudocode-Kommentar und Python-Implementation. Zeigt iterativen Ansatz."
    },
    {
      "language": "java",
      "title": "Java: Binäre Suche",
      "code": "/**\n * Binäre Suche in sortiertem Array\n * \n * Pseudocode:\n * FUNCTION binaere_suche(array, ziel)\n * BEGIN\n *     links = 0\n *     rechts = länge(array) - 1\n *     \n *     WHILE links <= rechts DO\n *         mitte = (links + rechts) / 2\n *         \n *         IF array[mitte] == ziel THEN\n *             RETURN mitte\n *         ELSE IF array[mitte] < ziel THEN\n *             links = mitte + 1\n *         ELSE\n *             rechts = mitte - 1\n *         END IF\n *     END WHILE\n *     \n *     RETURN -1  // Nicht gefunden\n * END\n */\npublic class BinaereSuche {\n    \n    public static int binaereSuche(int[] array, int ziel) {\n        int links = 0;\n        int rechts = array.length - 1;\n        \n        while (links <= rechts) {\n            // Mitte berechnen (verhindert Overflow)\n            int mitte = links + (rechts - links) / 2;\n            \n            if (array[mitte] == ziel) {\n                return mitte;  // Gefunden!\n            } else if (array[mitte] < ziel) {\n                // Ziel ist in rechter Hälfte\n                links = mitte + 1;\n            } else {\n                // Ziel ist in linker Hälfte\n                rechts = mitte - 1;\n            }\n        }\n        \n        return -1;  // Nicht gefunden\n    }\n    \n    public static void main(String[] args) {\n        int[] sortierteZahlen = {2, 5, 8, 12, 16, 23, 38, 45, 56, 67, 78};\n        \n        // Suche nach 23\n        int index = binaereSuche(sortierteZahlen, 23);\n        if (index != -1) {\n            System.out.println(\"23 gefunden an Index: \" + index);  // Index 5\n        }\n        \n        // Suche nach 100 (nicht vorhanden)\n        index = binaereSuche(sortierteZahlen, 100);\n        if (index == -1) {\n            System.out.println(\"100 nicht gefunden\");\n        }\n    }\n}",
      "explanation": "Binäre Suche mit Pseudocode und Java-Code. Zeigt effizienten Suchalgorithmus mit O(log n) Komplexität."
    },
    {
      "language": "pseudocode",
      "title": "Pseudocode: Passwort-Validierung",
      "code": "FUNCTION validiere_passwort(passwort)\nBEGIN\n    min_laenge = 8\n    hat_grossbuchstabe = false\n    hat_kleinbuchstabe = false\n    hat_ziffer = false\n    hat_sonderzeichen = false\n    \n    // Länge prüfen\n    IF länge(passwort) < min_laenge THEN\n        RETURN \"Passwort muss mindestens \" + min_laenge + \" Zeichen lang sein\"\n    END IF\n    \n    // Zeichen durchgehen\n    FOR EACH zeichen IN passwort DO\n        IF zeichen ist Großbuchstabe THEN\n            hat_grossbuchstabe = true\n        ELSE IF zeichen ist Kleinbuchstabe THEN\n            hat_kleinbuchstabe = true\n        ELSE IF zeichen ist Ziffer THEN\n            hat_ziffer = true\n        ELSE IF zeichen ist Sonderzeichen THEN\n            hat_sonderzeichen = true\n        END IF\n    END FOR\n    \n    // Alle Kriterien prüfen\n    IF NOT hat_grossbuchstabe THEN\n        RETURN \"Passwort muss mindestens einen Großbuchstaben enthalten\"\n    END IF\n    \n    IF NOT hat_kleinbuchstabe THEN\n        RETURN \"Passwort muss mindestens einen Kleinbuchstaben enthalten\"\n    END IF\n    \n    IF NOT hat_ziffer THEN\n        RETURN \"Passwort muss mindestens eine Ziffer enthalten\"\n    END IF\n    \n    IF NOT hat_sonderzeichen THEN\n        RETURN \"Passwort muss mindestens ein Sonderzeichen enthalten\"\n    END IF\n    \n    RETURN \"Passwort ist gültig\"\nEND\n\n// Verwendung\nBEGIN\n    passwort1 = \"test\"  // Zu kurz\n    passwort2 = \"TestPasswort\"  // Keine Ziffer, kein Sonderzeichen\n    passwort3 = \"TestPass123!\"  // Gültig\n    \n    OUTPUT validiere_passwort(passwort1)\n    OUTPUT validiere_passwort(passwort2)\n    OUTPUT validiere_passwort(passwort3)\nEND",
      "explanation": "Passwort-Validierung in Pseudocode. Zeigt komplexe Bedingungsprüfung und String-Verarbeitung."
    }
  ],
  "relatedQuizzes": ["fue-02-control-structures-quiz"],
  "resources": [
    {
      "title": "UML Activity Diagrams",
      "url": "https://www.uml-diagrams.org/activity-diagrams.html",
      "type": "documentation"
    },
    {
      "title": "Pseudocode Standards",
      "url": "https://www.geeksforgeeks.org/how-to-write-a-pseudo-code/",
      "type": "article"
    }
  ],
  "lastUpdated": "2025-01-05T10:00:00Z",
  "version": "1.0"
}
