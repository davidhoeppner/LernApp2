{
  "modules": [
    {
      "id": "bp-dpa-01-er-modeling",
      "title": "ER-Modellierung und Datenmodellierung",
      "description": "Grundlagen der Entity-Relationship-Modellierung und konzeptionelle Datenmodellierung",
      "category": "BP-DPA-02",
      "subcategory": "Datenmodelle entwickeln und implementieren",
      "difficulty": "intermediate",
      "examRelevance": "high",
      "newIn2025": false,
      "removedIn2025": false,
      "important": true,
      "estimatedTime": 60,
      "prerequisites": [],
      "tags": ["ER-Modell", "Datenmodellierung", "Entitäten", "Beziehungen", "Kardinalitäten"],
      "content": "# ER-Modellierung und Datenmodellierung\n\n## Einführung\n\nDie Entity-Relationship-Modellierung (ER-Modellierung) ist eine grundlegende Methode zur konzeptionellen Darstellung von Datenstrukturen. Sie bildet die Basis für die Entwicklung relationaler Datenbanken und ist essentiell für Fachinformatiker der Fachrichtung Daten- und Prozessanalyse.\n\n## Grundkonzepte der ER-Modellierung\n\n### 1. Entitäten (Entities)\n\n**Definition:**\n- Objekte oder Konzepte der realen Welt\n- Eindeutig identifizierbar\n- Haben Eigenschaften (Attribute)\n\n**Beispiele:**\n- Kunde, Produkt, Bestellung, Mitarbeiter\n- Darstellung: Rechteck\n\n**Entitätstyp vs. Entitätsausprägung:**\n- Entitätstyp: Allgemeine Beschreibung (z.B. \"Kunde\")\n- Entitätsausprägung: Konkrete Instanz (z.B. \"Max Mustermann\")\n\n### 2. Attribute\n\n**Arten von Attributen:**\n\n**Einfache Attribute:**\n- Nicht weiter zerlegbar\n- Beispiel: Nachname, Geburtsdatum\n\n**Zusammengesetzte Attribute:**\n- Aus mehreren Teilattributen bestehend\n- Beispiel: Adresse (Straße, PLZ, Ort)\n\n**Einwertige vs. Mehrwertige Attribute:**\n- Einwertig: Ein Wert pro Entität (z.B. Geburtsdatum)\n- Mehrwertig: Mehrere Werte möglich (z.B. Telefonnummern)\n\n**Abgeleitete Attribute:**\n- Aus anderen Attributen berechenbar\n- Beispiel: Alter (aus Geburtsdatum)\n- Darstellung: Gestrichelte Ellipse\n\n### 3. Schlüssel\n\n**Primärschlüssel (Primary Key):**\n- Eindeutige Identifikation einer Entität\n- Darf nicht NULL sein\n- Sollte unveränderlich sein\n- Beispiel: Kundennummer, Produktcode\n\n**Fremdschlüssel (Foreign Key):**\n- Verweis auf Primärschlüssel einer anderen Tabelle\n- Stellt Beziehungen zwischen Entitäten her\n\n**Kandidatenschlüssel:**\n- Alle möglichen Schlüssel einer Entität\n- Einer wird als Primärschlüssel gewählt\n\n**Superschlüssel:**\n- Attributkombination, die Entitäten eindeutig identifiziert\n- Kann redundante Attribute enthalten\n\n### 4. Beziehungen (Relationships)\n\n**Definition:**\n- Verbindungen zwischen Entitäten\n- Beschreiben Zusammenhänge\n- Darstellung: Raute\n\n**Beziehungstypen nach Kardinalität:**\n\n**1:1 (Eins-zu-Eins):**\n- Eine Entität steht mit maximal einer anderen in Beziehung\n- Beispiel: Person - Personalausweis\n- Seltener Fall, oft zusammenfassbar\n\n**1:N (Eins-zu-Viele):**\n- Eine Entität steht mit mehreren anderen in Beziehung\n- Beispiel: Kunde - Bestellungen\n- Häufigster Fall\n\n**N:M (Viele-zu-Viele):**\n- Mehrere Entitäten stehen mit mehreren anderen in Beziehung\n- Beispiel: Studenten - Kurse\n- Erfordert Zwischentabelle bei Umsetzung\n\n### 5. Kardinalitäten\n\n**Min-Max-Notation:**\n- (min, max) an jeder Seite der Beziehung\n- min: Mindestanzahl der Beziehungen\n- max: Höchstanzahl der Beziehungen\n\n**Beispiele:**\n- (0,1): Optional, maximal eine Beziehung\n- (1,1): Genau eine Beziehung (Pflicht)\n- (0,*): Beliebig viele Beziehungen\n- (1,*): Mindestens eine Beziehung\n\n## ER-Diagramm Notation\n\n### Chen-Notation (Original)\n- Entitäten: Rechtecke\n- Attribute: Ellipsen\n- Beziehungen: Rauten\n- Verbindungslinien zwischen Elementen\n\n### Crow's Foot Notation\n- Kompakter und übersichtlicher\n- Kardinalitäten durch Symbole an Linienenden\n- Weit verbreitet in der Praxis\n\n### UML-Klassendiagramm\n- Moderne Alternative\n- Integriert in UML-Standard\n- Zeigt auch Methoden und Operationen\n\n## Modellierungsprozess\n\n### Schritt 1: Anforderungsanalyse\n- Geschäftsregeln verstehen\n- Datenquellen identifizieren\n- Stakeholder befragen\n\n### Schritt 2: Entitäten identifizieren\n- Substantive in Anforderungen finden\n- Relevante Objekte bestimmen\n- Entitätstypen definieren\n\n### Schritt 3: Attribute bestimmen\n- Eigenschaften der Entitäten\n- Datentypen festlegen\n- Schlüssel identifizieren\n\n### Schritt 4: Beziehungen modellieren\n- Zusammenhänge zwischen Entitäten\n- Kardinalitäten bestimmen\n- Geschäftsregeln berücksichtigen\n\n### Schritt 5: Validierung\n- Modell mit Stakeholdern prüfen\n- Vollständigkeit sicherstellen\n- Konsistenz überprüfen\n\n## Erweiterte Konzepte\n\n### Schwache Entitäten\n- Können nicht allein durch eigene Attribute identifiziert werden\n- Benötigen Beziehung zu starker Entität\n- Beispiel: Zimmer (abhängig von Hotel)\n- Darstellung: Doppeltes Rechteck\n\n### Spezialisierung/Generalisierung\n- ISA-Beziehungen (\"ist ein\")\n- Vererbung von Attributen\n- Beispiel: Person → Kunde, Mitarbeiter\n\n### Aggregation\n- \"Teil-von\"-Beziehungen\n- Zusammensetzung komplexer Objekte\n- Beispiel: Auto besteht aus Motor, Rädern\n\n## Praktisches Beispiel: Online-Shop\n\n### Entitäten:\n- Kunde (KundenID, Name, Email, Adresse)\n- Produkt (ProduktID, Name, Preis, Beschreibung)\n- Bestellung (BestellID, Datum, Status)\n- Kategorie (KategorieID, Name)\n\n### Beziehungen:\n- Kunde (1) - (N) Bestellung\n- Bestellung (N) - (M) Produkt (über Bestellposition)\n- Produkt (N) - (1) Kategorie\n\n### Kardinalitäten:\n- Ein Kunde kann mehrere Bestellungen haben (1:N)\n- Eine Bestellung kann mehrere Produkte enthalten (N:M)\n- Ein Produkt gehört zu einer Kategorie (N:1)\n\n## Häufige Modellierungsfehler\n\n### 1. Falsche Kardinalitäten\n- Geschäftsregeln nicht richtig verstanden\n- Ausnahmen nicht berücksichtigt\n\n### 2. Fehlende Entitäten\n- Wichtige Objekte übersehen\n- Zwischentabellen vergessen\n\n### 3. Übermodellierung\n- Zu viele Details im konzeptionellen Modell\n- Implementierungsdetails zu früh berücksichtigt\n\n### 4. Attribut vs. Entität\n- Falsche Entscheidung zwischen Attribut und eigener Entität\n- Regel: Wenn weitere Attribute möglich → eigene Entität\n\n## Übergang zum relationalen Modell\n\n### Transformationsregeln:\n1. Jede Entität wird zu einer Tabelle\n2. Attribute werden zu Spalten\n3. 1:N-Beziehungen: Fremdschlüssel in N-Seite\n4. N:M-Beziehungen: Separate Zwischentabelle\n5. 1:1-Beziehungen: Fremdschlüssel oder Zusammenfassung\n\n## Prüfungsrelevante Aspekte\n\n- ER-Diagramme lesen und erstellen\n- Kardinalitäten korrekt bestimmen\n- Entitäten und Attribute unterscheiden\n- Schlüssel identifizieren\n- Beziehungstypen erkennen\n- Transformationsregeln anwenden\n- Modellierungsfehler erkennen",
      "codeExamples": [],
      "relatedQuizzes": ["bp-dpa-01-er-modeling-quiz"],
      "resources": [
        {
          "title": "ER-Modellierung Tutorial",
          "url": "https://www.lucidchart.com/pages/er-diagrams",
          "type": "article"
        }
      ],
      "learningObjectives": [
        "ER-Diagramme erstellen und interpretieren",
        "Entitäten, Attribute und Beziehungen identifizieren",
        "Kardinalitäten korrekt bestimmen",
        "Schlüssel definieren und verwenden",
        "Modellierungsfehler erkennen und vermeiden"
      ],
      "keyTakeaways": [
        "ER-Modellierung ist die Basis für Datenbankdesign",
        "Kardinalitäten beschreiben Beziehungen zwischen Entitäten",
        "Primärschlüssel identifizieren Entitäten eindeutig",
        "N:M-Beziehungen erfordern Zwischentabellen"
      ],
      "lastUpdated": "2025-01-20T00:00:00Z",
      "version": "1.0"
    },
    {
      "id": "bp-dpa-01-normalization",
      "title": "Normalisierung von Datenbanken",
      "description": "Normalformen und Normalisierungsprozess zur Vermeidung von Redundanzen und Anomalien",
      "category": "BP-DPA-02",
      "subcategory": "Datenmodelle entwickeln und implementieren",
      "difficulty": "intermediate",
      "examRelevance": "high",
      "newIn2025": false,
      "removedIn2025": false,
      "important": true,
      "estimatedTime": 50,
      "prerequisites": ["bp-dpa-01-er-modeling"],
      "tags": ["Normalisierung", "Normalformen", "Redundanz", "Anomalien", "Datenbankdesign"],
      "content": "# Normalisierung von Datenbanken\n\n## Einführung\n\nNormalisierung ist ein systematischer Prozess zur Strukturierung relationaler Datenbanken, um Redundanzen zu minimieren und Datenintegrität zu gewährleisten. Für Fachinformatiker der Fachrichtung Daten- und Prozessanalyse ist das Verständnis der Normalformen essentiell für effizientes Datenbankdesign.\n\n## Ziele der Normalisierung\n\n### 1. Redundanz minimieren\n- Vermeidung doppelt gespeicherter Daten\n- Reduzierung des Speicherbedarfs\n- Konsistenz der Daten sicherstellen\n\n### 2. Anomalien vermeiden\n- **Einfügeanomalie**: Daten können nicht eingefügt werden ohne andere Daten\n- **Änderungsanomalie**: Änderungen müssen an mehreren Stellen vorgenommen werden\n- **Löschanomalie**: Beim Löschen gehen ungewollt andere Daten verloren\n\n### 3. Datenintegrität gewährleisten\n- Konsistente Datenstrukturen\n- Eindeutige Beziehungen\n- Referentielle Integrität\n\n## Funktionale Abhängigkeiten\n\n### Definition\nEin Attribut B ist funktional abhängig von Attribut A, wenn zu jedem Wert von A genau ein Wert von B gehört.\n\n**Notation:** A → B (\"A bestimmt B\")\n\n### Beispiele\n- PersonalNr → Name (Personalnummer bestimmt Namen)\n- ISBN → Buchtitel (ISBN bestimmt Buchtitel)\n- KundenNr → Adresse (Kundennummer bestimmt Adresse)\n\n### Arten funktionaler Abhängigkeiten\n\n**Vollständige funktionale Abhängigkeit:**\n- B ist von der gesamten Attributkombination A abhängig\n- Entfernung eines Attributs aus A würde Abhängigkeit aufheben\n\n**Partielle funktionale Abhängigkeit:**\n- B ist nur von einem Teil der Attributkombination A abhängig\n- Verletzt die 2. Normalform\n\n**Transitive Abhängigkeit:**\n- A → B und B → C, dann A → C\n- Indirekte Abhängigkeit über Zwischenattribut\n- Verletzt die 3. Normalform\n\n## Die Normalformen\n\n### 1. Normalform (1NF)\n\n**Bedingung:**\n- Alle Attributwerte sind atomar (unteilbar)\n- Keine mehrwertigen Attribute\n- Keine Wiederholungsgruppen\n\n**Beispiel - Nicht in 1NF:**\n```\nKunde (KundenNr, Name, Telefon)\n1, \"Max Müller\", \"030-123456, 0171-987654\"\n```\n\n**Beispiel - In 1NF:**\n```\nKunde (KundenNr, Name)\n1, \"Max Müller\"\n\nTelefon (KundenNr, Telefonnummer)\n1, \"030-123456\"\n1, \"0171-987654\"\n```\n\n### 2. Normalform (2NF)\n\n**Bedingungen:**\n- Tabelle ist in 1NF\n- Jedes Nicht-Schlüssel-Attribut ist vollständig funktional abhängig vom Primärschlüssel\n- Keine partiellen Abhängigkeiten\n\n**Beispiel - Nicht in 2NF:**\n```\nBestellposition (BestellNr, ProduktNr, Menge, Produktname, Preis)\nPrimärschlüssel: (BestellNr, ProduktNr)\n```\n\nProblem: Produktname und Preis sind nur von ProduktNr abhängig, nicht vom gesamten Schlüssel.\n\n**Lösung - In 2NF:**\n```\nBestellposition (BestellNr, ProduktNr, Menge)\nProdukt (ProduktNr, Produktname, Preis)\n```\n\n### 3. Normalform (3NF)\n\n**Bedingungen:**\n- Tabelle ist in 2NF\n- Kein Nicht-Schlüssel-Attribut ist transitiv abhängig vom Primärschlüssel\n- Keine transitiven Abhängigkeiten\n\n**Beispiel - Nicht in 3NF:**\n```\nMitarbeiter (PersonalNr, Name, AbteilungsNr, Abteilungsname)\n```\n\nProblem: Abteilungsname ist transitiv abhängig (PersonalNr → AbteilungsNr → Abteilungsname)\n\n**Lösung - In 3NF:**\n```\nMitarbeiter (PersonalNr, Name, AbteilungsNr)\nAbteilung (AbteilungsNr, Abteilungsname)\n```\n\n### Boyce-Codd-Normalform (BCNF)\n\n**Bedingung:**\n- Tabelle ist in 3NF\n- Jede funktionale Abhängigkeit hat einen Superschlüssel als Determinante\n- Verschärfung der 3NF\n\n**Anwendung:**\n- Bei mehreren Kandidatenschlüsseln\n- Seltener in der Praxis relevant\n\n### 4. Normalform (4NF)\n\n**Bedingung:**\n- Tabelle ist in BCNF\n- Keine mehrwertigen Abhängigkeiten\n\n**Beispiel:**\n```\nStudent-Kurs-Hobby (StudentNr, Kurs, Hobby)\n```\n\nProblem: Kurse und Hobbys sind unabhängig voneinander mehrwertig.\n\n**Lösung:**\n```\nStudent-Kurs (StudentNr, Kurs)\nStudent-Hobby (StudentNr, Hobby)\n```\n\n### 5. Normalform (5NF)\n\n**Bedingung:**\n- Tabelle ist in 4NF\n- Keine Verbundabhängigkeiten\n- Sehr selten in der Praxis relevant\n\n## Normalisierungsprozess\n\n### Schritt 1: Ausgangstabelle analysieren\n- Funktionale Abhängigkeiten identifizieren\n- Primärschlüssel bestimmen\n- Anomalien erkennen\n\n### Schritt 2: 1NF erreichen\n- Mehrwertige Attribute auflösen\n- Wiederholungsgruppen eliminieren\n- Atomare Werte sicherstellen\n\n### Schritt 3: 2NF erreichen\n- Partielle Abhängigkeiten identifizieren\n- Betroffene Attribute in neue Tabellen auslagern\n- Fremdschlüssel-Beziehungen erstellen\n\n### Schritt 4: 3NF erreichen\n- Transitive Abhängigkeiten identifizieren\n- Zwischentabellen für transitive Beziehungen erstellen\n- Referentielle Integrität sicherstellen\n\n## Praktisches Beispiel: Bibliothekssystem\n\n### Ausgangstabelle (nicht normalisiert):\n```\nAusleihe (\n  AusleihNr, \n  Datum, \n  LeserNr, \n  LeserName, \n  LeserAdresse,\n  ISBN, \n  Buchtitel, \n  Autor, \n  Verlag,\n  Rückgabedatum\n)\n```\n\n### Funktionale Abhängigkeiten:\n- AusleihNr → Datum, LeserNr, ISBN, Rückgabedatum\n- LeserNr → LeserName, LeserAdresse\n- ISBN → Buchtitel, Autor, Verlag\n\n### Nach Normalisierung (3NF):\n```\nAusleihe (AusleihNr, Datum, LeserNr, ISBN, Rückgabedatum)\nLeser (LeserNr, LeserName, LeserAdresse)\nBuch (ISBN, Buchtitel, Autor, Verlag)\n```\n\n## Vor- und Nachteile der Normalisierung\n\n### Vorteile:\n- Reduzierte Redundanz\n- Vermeidung von Anomalien\n- Bessere Datenintegrität\n- Flexiblere Datenstruktur\n- Geringerer Speicherbedarf\n\n### Nachteile:\n- Komplexere Abfragen (mehr JOINs)\n- Potentiell schlechtere Performance\n- Höhere Komplexität der Datenbankstruktur\n\n## Denormalisierung\n\n### Wann sinnvoll?\n- Performance-kritische Anwendungen\n- Read-heavy Workloads\n- Data Warehouse Systeme\n- Reporting-Datenbanken\n\n### Strategien:\n- Kontrollierte Redundanz\n- Materialized Views\n- Berechnete Felder\n- Zusammenfassung häufig abgefragter Daten\n\n## Prüfungsrelevante Aspekte\n\n- Normalformen 1NF bis 3NF sicher beherrschen\n- Funktionale Abhängigkeiten erkennen\n- Anomalien identifizieren\n- Normalisierungsprozess durchführen\n- Vor- und Nachteile der Normalisierung kennen\n- Praktische Beispiele normalisieren können",
      "codeExamples": [
        {
          "language": "sql",
          "code": "-- Beispiel: Nicht normalisierte Tabelle\nCREATE TABLE bestellung_nicht_normalisiert (\n    bestell_nr INT,\n    kunde_nr INT,\n    kunde_name VARCHAR(100),\n    kunde_adresse VARCHAR(200),\n    produkt_nr INT,\n    produkt_name VARCHAR(100),\n    preis DECIMAL(10,2),\n    menge INT\n);\n\n-- Nach Normalisierung (3NF):\nCREATE TABLE kunde (\n    kunde_nr INT PRIMARY KEY,\n    kunde_name VARCHAR(100),\n    kunde_adresse VARCHAR(200)\n);\n\nCREATE TABLE produkt (\n    produkt_nr INT PRIMARY KEY,\n    produkt_name VARCHAR(100),\n    preis DECIMAL(10,2)\n);\n\nCREATE TABLE bestellung (\n    bestell_nr INT PRIMARY KEY,\n    kunde_nr INT,\n    FOREIGN KEY (kunde_nr) REFERENCES kunde(kunde_nr)\n);\n\nCREATE TABLE bestellposition (\n    bestell_nr INT,\n    produkt_nr INT,\n    menge INT,\n    PRIMARY KEY (bestell_nr, produkt_nr),\n    FOREIGN KEY (bestell_nr) REFERENCES bestellung(bestell_nr),\n    FOREIGN KEY (produkt_nr) REFERENCES produkt(produkt_nr)\n);",
          "explanation": "Beispiel für Normalisierung einer Bestelltabelle von unnormalisiert zu 3NF",
          "title": "Normalisierung Beispiel"
        }
      ],
      "relatedQuizzes": ["bp-dpa-01-normalization-quiz"],
      "resources": [
        {
          "title": "Database Normalization Explained",
          "url": "https://www.studytonight.com/dbms/database-normalization.php",
          "type": "article"
        }
      ],
      "learningObjectives": [
        "Normalformen 1NF bis 3NF verstehen und anwenden",
        "Funktionale Abhängigkeiten identifizieren",
        "Anomalien erkennen und vermeiden",
        "Normalisierungsprozess durchführen",
        "Vor- und Nachteile der Normalisierung bewerten"
      ],
      "keyTakeaways": [
        "Normalisierung reduziert Redundanz und Anomalien",
        "Funktionale Abhängigkeiten bestimmen die Normalformen",
        "3NF ist meist ausreichend für praktische Anwendungen",
        "Denormalisierung kann für Performance sinnvoll sein"
      ],
      "lastUpdated": "2025-01-20T00:00:00Z",
      "version": "1.0"
    }
  ]
}