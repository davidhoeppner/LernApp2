{
  "id": "bp-05-sorting",
  "title": "Sortierverfahren - Bubble, Selection und Insertion Sort",
  "description": "Lerne die grundlegenden Sortieralgorithmen Bubble Sort, Selection Sort und Insertion Sort mit Visualisierungen und KomplexitÃ¤tsanalyse.",
  "category": "BP-05",
  "subcategory": "OOP und Algorithmen",
  "difficulty": "intermediate",
  "examRelevance": "high",
  "newIn2025": true,
  "removedIn2025": false,
  "important": true,
  "estimatedTime": 60,
  "prerequisites": [],
  "tags": ["Sortieralgorithmen", "Bubble Sort", "Selection Sort", "Insertion Sort", "ZeitkomplexitÃ¤t", "Big-O", "Neu 2025"],
  "content": "# Sortierverfahren\n\n## EinfÃ¼hrung\n\nSortieralgorithmen sind fundamentale Algorithmen in der Informatik, die eine Liste von Elementen in eine bestimmte Reihenfolge bringen. In der IHK-PrÃ¼fung sind besonders **Bubble Sort**, **Selection Sort** und **Insertion Sort** relevant.\n\n## Warum Sortieren wichtig ist\n\n- **Suche beschleunigen:** Sortierte Daten ermÃ¶glichen binÃ¤re Suche (O(log n))\n- **Daten organisieren:** Bessere Ãœbersicht und Analyse\n- **Algorithmen-VerstÃ¤ndnis:** Grundlage fÃ¼r komplexere Algorithmen\n- **Praxisrelevanz:** Datenbanken, Suchmaschinen, Dateisysteme\n\n## ZeitkomplexitÃ¤t - Big-O Notation\n\nDie **Big-O Notation** beschreibt, wie die Laufzeit eines Algorithmus mit der EingabegrÃ¶ÃŸe wÃ¤chst.\n\n### Wichtige KomplexitÃ¤tsklassen\n\n- **O(1)** - Konstant: UnabhÃ¤ngig von EingabegrÃ¶ÃŸe\n- **O(log n)** - Logarithmisch: Sehr effizient (z.B. binÃ¤re Suche)\n- **O(n)** - Linear: Proportional zur EingabegrÃ¶ÃŸe\n- **O(n log n)** - Linearithmisch: Effiziente Sortieralgorithmen (z.B. Merge Sort)\n- **O(nÂ²)** - Quadratisch: Ineffizient bei groÃŸen Datenmengen\n- **O(2â¿)** - Exponentiell: Sehr ineffizient\n\n### Best, Average, Worst Case\n\n- **Best Case:** Beste mÃ¶gliche Laufzeit (z.B. bereits sortierte Liste)\n- **Average Case:** Durchschnittliche Laufzeit\n- **Worst Case:** Schlechteste mÃ¶gliche Laufzeit (z.B. umgekehrt sortierte Liste)\n\n## 1. Bubble Sort (Blasensortierung)\n\n### Funktionsweise\n\nBubble Sort vergleicht **benachbarte Elemente** und tauscht sie, wenn sie in falscher Reihenfolge sind. Dieser Prozess wird wiederholt, bis die Liste sortiert ist.\n\n**Metapher:** Wie Blasen im Wasser steigen die grÃ¶ÃŸten Elemente nach oben.\n\n### Algorithmus-Schritte\n\n1. Durchlaufe die Liste von links nach rechts\n2. Vergleiche jedes Element mit seinem Nachbarn\n3. Tausche die Elemente, wenn sie in falscher Reihenfolge sind\n4. Wiederhole, bis keine Tauschoperationen mehr nÃ¶tig sind\n\n### Visualisierung\n\n```\nUnsortiert: [5, 2, 8, 1, 9]\n\nDurchlauf 1:\n[5, 2, 8, 1, 9] â†’ [2, 5, 8, 1, 9]  (5 und 2 tauschen)\n[2, 5, 8, 1, 9] â†’ [2, 5, 8, 1, 9]  (5 und 8 OK)\n[2, 5, 8, 1, 9] â†’ [2, 5, 1, 8, 9]  (8 und 1 tauschen)\n[2, 5, 1, 8, 9] â†’ [2, 5, 1, 8, 9]  (8 und 9 OK)\n\nDurchlauf 2:\n[2, 5, 1, 8, 9] â†’ [2, 5, 1, 8, 9]  (2 und 5 OK)\n[2, 5, 1, 8, 9] â†’ [2, 1, 5, 8, 9]  (5 und 1 tauschen)\n[2, 1, 5, 8, 9] â†’ [2, 1, 5, 8, 9]  (5 und 8 OK)\n\nDurchlauf 3:\n[2, 1, 5, 8, 9] â†’ [1, 2, 5, 8, 9]  (2 und 1 tauschen)\n\nSortiert: [1, 2, 5, 8, 9]\n```\n\n### KomplexitÃ¤t\n\n- **Best Case:** O(n) - Liste bereits sortiert (mit Optimierung)\n- **Average Case:** O(nÂ²)\n- **Worst Case:** O(nÂ²) - Liste umgekehrt sortiert\n- **Speicher:** O(1) - In-Place Sortierung\n\n### Eigenschaften\n\nâœ… **Stabil:** Gleiche Elemente behalten ihre relative Reihenfolge\n\nâœ… **In-Place:** BenÃ¶tigt keinen zusÃ¤tzlichen Speicher\n\nâŒ **Ineffizient:** Langsam bei groÃŸen Datenmengen\n\n## 2. Selection Sort (Auswahlsortierung)\n\n### Funktionsweise\n\nSelection Sort sucht in jedem Durchlauf das **kleinste Element** und platziert es an der richtigen Position.\n\n**Metapher:** Wie beim Kartensortieren - suche die kleinste Karte und lege sie ganz links ab.\n\n### Algorithmus-Schritte\n\n1. Finde das kleinste Element in der unsortierten Liste\n2. Tausche es mit dem ersten Element\n3. Finde das zweitkleinste Element\n4. Tausche es mit dem zweiten Element\n5. Wiederhole, bis die Liste sortiert ist\n\n### Visualisierung\n\n```\nUnsortiert: [5, 2, 8, 1, 9]\n           ^\nDurchlauf 1: Suche Minimum (1)\n[5, 2, 8, 1, 9] â†’ [1, 2, 8, 5, 9]\n ^        ^         (1 und 5 tauschen)\n\nDurchlauf 2: Suche Minimum in [2, 8, 5, 9] â†’ 2\n[1, 2, 8, 5, 9] â†’ [1, 2, 8, 5, 9]\n    ^              (2 bereits an richtiger Position)\n\nDurchlauf 3: Suche Minimum in [8, 5, 9] â†’ 5\n[1, 2, 8, 5, 9] â†’ [1, 2, 5, 8, 9]\n       ^  ^         (5 und 8 tauschen)\n\nDurchlauf 4: Suche Minimum in [8, 9] â†’ 8\n[1, 2, 5, 8, 9] â†’ [1, 2, 5, 8, 9]\n          ^        (8 bereits an richtiger Position)\n\nSortiert: [1, 2, 5, 8, 9]\n```\n\n### KomplexitÃ¤t\n\n- **Best Case:** O(nÂ²)\n- **Average Case:** O(nÂ²)\n- **Worst Case:** O(nÂ²)\n- **Speicher:** O(1) - In-Place Sortierung\n\n### Eigenschaften\n\nâŒ **Nicht stabil:** Kann relative Reihenfolge Ã¤ndern\n\nâœ… **In-Place:** BenÃ¶tigt keinen zusÃ¤tzlichen Speicher\n\nâœ… **Wenige Tauschoperationen:** Maximal n-1 Tausche\n\nâŒ **Immer O(nÂ²):** Auch bei bereits sortierten Listen\n\n## 3. Insertion Sort (EinfÃ¼gesortierung)\n\n### Funktionsweise\n\nInsertion Sort baut eine sortierte Liste auf, indem jedes Element an der **richtigen Position eingefÃ¼gt** wird.\n\n**Metapher:** Wie beim Kartensortieren in der Hand - nimm eine Karte und fÃ¼ge sie an der richtigen Stelle ein.\n\n### Algorithmus-Schritte\n\n1. Beginne mit dem zweiten Element\n2. Vergleiche es mit den Elementen links davon\n3. Verschiebe grÃ¶ÃŸere Elemente nach rechts\n4. FÃ¼ge das Element an der richtigen Position ein\n5. Wiederhole fÃ¼r alle Elemente\n\n### Visualisierung\n\n```\nUnsortiert: [5, 2, 8, 1, 9]\n\nSchritt 1: FÃ¼ge 2 ein\n[5 | 2, 8, 1, 9]\n[2, 5 | 8, 1, 9]  (2 vor 5 einfÃ¼gen)\n\nSchritt 2: FÃ¼ge 8 ein\n[2, 5 | 8, 1, 9]\n[2, 5, 8 | 1, 9]  (8 ist bereits richtig)\n\nSchritt 3: FÃ¼ge 1 ein\n[2, 5, 8 | 1, 9]\n[1, 2, 5, 8 | 9]  (1 ganz vorne einfÃ¼gen)\n\nSchritt 4: FÃ¼ge 9 ein\n[1, 2, 5, 8 | 9]\n[1, 2, 5, 8, 9]   (9 ist bereits richtig)\n\nSortiert: [1, 2, 5, 8, 9]\n```\n\n### KomplexitÃ¤t\n\n- **Best Case:** O(n) - Liste bereits sortiert\n- **Average Case:** O(nÂ²)\n- **Worst Case:** O(nÂ²) - Liste umgekehrt sortiert\n- **Speicher:** O(1) - In-Place Sortierung\n\n### Eigenschaften\n\nâœ… **Stabil:** Gleiche Elemente behalten ihre relative Reihenfolge\n\nâœ… **In-Place:** BenÃ¶tigt keinen zusÃ¤tzlichen Speicher\n\nâœ… **Effizient fÃ¼r kleine Listen:** Besser als Bubble/Selection Sort\n\nâœ… **Effizient fÃ¼r fast sortierte Listen:** O(n) im Best Case\n\nâœ… **Online-Algorithmus:** Kann Elemente wÃ¤hrend der Eingabe sortieren\n\n## Vergleich der Sortierverfahren\n\n| Eigenschaft | Bubble Sort | Selection Sort | Insertion Sort |\n|-------------|-------------|----------------|----------------|\n| **Best Case** | O(n)* | O(nÂ²) | O(n) |\n| **Average Case** | O(nÂ²) | O(nÂ²) | O(nÂ²) |\n| **Worst Case** | O(nÂ²) | O(nÂ²) | O(nÂ²) |\n| **Speicher** | O(1) | O(1) | O(1) |\n| **Stabil** | âœ… Ja | âŒ Nein | âœ… Ja |\n| **Tauschoperationen** | Viele | Wenige | Mittel |\n| **Vergleiche** | Viele | Viele | Wenige (Best Case) |\n| **Geeignet fÃ¼r** | Kleine Listen | Kleine Listen | Fast sortierte Listen |\n\n*mit Optimierung (Early Exit)\n\n## Wann welchen Algorithmus verwenden?\n\n### Bubble Sort\n- âœ… Lernzwecke und einfache Implementierung\n- âœ… Sehr kleine Datenmengen (< 10 Elemente)\n- âŒ Produktivcode (zu ineffizient)\n\n### Selection Sort\n- âœ… Wenn Tauschoperationen teuer sind\n- âœ… Kleine Datenmengen\n- âŒ Wenn StabilitÃ¤t wichtig ist\n\n### Insertion Sort\n- âœ… Fast sortierte Listen\n- âœ… Kleine bis mittlere Datenmengen\n- âœ… Online-Sortierung (Daten kommen nach und nach)\n- âœ… Als Teil von Hybrid-Algorithmen (z.B. Timsort)\n\n### FÃ¼r groÃŸe Datenmengen\n- âœ… **Merge Sort** - O(n log n), stabil\n- âœ… **Quick Sort** - O(n log n) average, in-place\n- âœ… **Heap Sort** - O(n log n), in-place\n\n## StabilitÃ¤t bei Sortieralgorithmen\n\n**Stabil** bedeutet: Elemente mit gleichem Wert behalten ihre ursprÃ¼ngliche Reihenfolge.\n\n**Beispiel:**\n```\nUnsortiert: [(3, A), (1, B), (3, C), (2, D)]\n\nStabil sortiert:   [(1, B), (2, D), (3, A), (3, C)]\n                                      â†‘ A vor C\n\nInstabil sortiert: [(1, B), (2, D), (3, C), (3, A)]\n                                      â†‘ C vor A (Reihenfolge geÃ¤ndert!)\n```\n\n**Wichtig bei:**\n- Mehrfachem Sortieren nach verschiedenen Kriterien\n- Sortierung von Objekten mit mehreren Attributen\n\n## Ãœbungsaufgaben\n\n### Aufgabe 1: Algorithmus erkennen\n\nWelcher Sortieralgorithmus wird hier verwendet?\n```\n[64, 25, 12, 22, 11]\n[11, 25, 12, 22, 64]  (11 und 64 getauscht)\n[11, 12, 25, 22, 64]  (12 und 25 getauscht)\n[11, 12, 22, 25, 64]  (22 und 25 getauscht)\n```\n\n### Aufgabe 2: KomplexitÃ¤t berechnen\n\nEine Liste hat 100 Elemente. Wie viele Vergleiche macht Selection Sort im Worst Case?\n\n### Aufgabe 3: Bester Algorithmus wÃ¤hlen\n\nWelcher Algorithmus ist am besten geeignet fÃ¼r:\na) Eine fast sortierte Liste mit 1000 Elementen?\nb) Eine Liste mit 5 Elementen?\nc) Eine Liste, bei der StabilitÃ¤t wichtig ist?\n\n### Aufgabe 4: Sortierung durchfÃ¼hren\n\nSortiere [3, 1, 4, 1, 5] mit Bubble Sort. Zeige jeden Durchlauf.\n\n### Aufgabe 5: Code-LÃ¼cken fÃ¼llen\n\nVervollstÃ¤ndige den Insertion Sort Code (siehe Code-Beispiele).\n\n## Zusammenfassung\n\nAlle drei Sortieralgorithmen haben eine ZeitkomplexitÃ¤t von **O(nÂ²)** im Average und Worst Case, sind aber fÃ¼r kleine Datenmengen und Lernzwecke geeignet.\n\n**MerksÃ¤tze:**\n- **Bubble Sort:** Tausche benachbarte Elemente\n- **Selection Sort:** WÃ¤hle das Minimum aus\n- **Insertion Sort:** FÃ¼ge Elemente sortiert ein\n\nFÃ¼r groÃŸe Datenmengen sollten effizientere Algorithmen wie Merge Sort oder Quick Sort verwendet werden.",
  "codeExamples": [
    {
      "language": "java",
      "title": "Bubble Sort - Java Implementierung",
      "code": "public class BubbleSort {\n    \n    public static void bubbleSort(int[] arr) {\n        int n = arr.length;\n        boolean swapped;\n        \n        // Ã„uÃŸere Schleife: DurchlÃ¤ufe\n        for (int i = 0; i < n - 1; i++) {\n            swapped = false;\n            \n            // Innere Schleife: Vergleiche benachbarte Elemente\n            for (int j = 0; j < n - i - 1; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    // Tausche arr[j] und arr[j+1]\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                    swapped = true;\n                }\n            }\n            \n            // Optimierung: Wenn keine Tausche, ist Liste sortiert\n            if (!swapped) {\n                break;\n            }\n        }\n    }\n    \n    public static void main(String[] args) {\n        int[] arr = {64, 34, 25, 12, 22, 11, 90};\n        \n        System.out.println(\"Unsortiert:\");\n        printArray(arr);\n        \n        bubbleSort(arr);\n        \n        System.out.println(\"\\nSortiert:\");\n        printArray(arr);\n    }\n    \n    public static void printArray(int[] arr) {\n        for (int value : arr) {\n            System.out.print(value + \" \");\n        }\n        System.out.println();\n    }\n}\n\n// Output:\n// Unsortiert: 64 34 25 12 22 11 90\n// Sortiert: 11 12 22 25 34 64 90",
      "explanation": "Bubble Sort mit Optimierung: Die Variable 'swapped' ermÃ¶glicht ein frÃ¼hzeitiges Beenden, wenn die Liste bereits sortiert ist. Dies verbessert den Best Case auf O(n)."
    },
    {
      "language": "python",
      "title": "Selection Sort - Python Implementierung",
      "code": "def selection_sort(arr):\n    n = len(arr)\n    \n    # Durchlaufe die gesamte Liste\n    for i in range(n):\n        # Finde das Minimum im unsortierten Teil\n        min_index = i\n        \n        for j in range(i + 1, n):\n            if arr[j] < arr[min_index]:\n                min_index = j\n        \n        # Tausche das gefundene Minimum mit dem ersten Element\n        arr[i], arr[min_index] = arr[min_index], arr[i]\n        \n        # Optional: Zeige jeden Schritt\n        print(f\"Durchlauf {i + 1}: {arr}\")\n    \n    return arr\n\n# Beispiel\narr = [64, 25, 12, 22, 11]\nprint(f\"Unsortiert: {arr}\")\nprint()\nsorted_arr = selection_sort(arr)\nprint(f\"\\nSortiert: {sorted_arr}\")\n\n# Output:\n# Unsortiert: [64, 25, 12, 22, 11]\n# \n# Durchlauf 1: [11, 25, 12, 22, 64]\n# Durchlauf 2: [11, 12, 25, 22, 64]\n# Durchlauf 3: [11, 12, 22, 25, 64]\n# Durchlauf 4: [11, 12, 22, 25, 64]\n# Durchlauf 5: [11, 12, 22, 25, 64]\n# \n# Sortiert: [11, 12, 22, 25, 64]",
      "explanation": "Selection Sort findet in jedem Durchlauf das Minimum und platziert es an der richtigen Position. Die Anzahl der Tauschoperationen ist minimal (maximal n-1)."
    },
    {
      "language": "java",
      "title": "Insertion Sort - Java Implementierung",
      "code": "public class InsertionSort {\n    \n    public static void insertionSort(int[] arr) {\n        int n = arr.length;\n        \n        // Beginne beim zweiten Element (Index 1)\n        for (int i = 1; i < n; i++) {\n            int key = arr[i];  // Element zum EinfÃ¼gen\n            int j = i - 1;\n            \n            // Verschiebe Elemente, die grÃ¶ÃŸer als key sind\n            while (j >= 0 && arr[j] > key) {\n                arr[j + 1] = arr[j];\n                j--;\n            }\n            \n            // FÃ¼ge key an der richtigen Position ein\n            arr[j + 1] = key;\n        }\n    }\n    \n    // Variante mit Visualisierung\n    public static void insertionSortVerbose(int[] arr) {\n        int n = arr.length;\n        \n        System.out.println(\"Start: \" + java.util.Arrays.toString(arr));\n        \n        for (int i = 1; i < n; i++) {\n            int key = arr[i];\n            int j = i - 1;\n            \n            System.out.println(\"\\nFÃ¼ge \" + key + \" ein:\");\n            \n            while (j >= 0 && arr[j] > key) {\n                arr[j + 1] = arr[j];\n                j--;\n            }\n            \n            arr[j + 1] = key;\n            System.out.println(java.util.Arrays.toString(arr));\n        }\n    }\n    \n    public static void main(String[] args) {\n        int[] arr = {12, 11, 13, 5, 6};\n        insertionSortVerbose(arr);\n    }\n}\n\n// Output:\n// Start: [12, 11, 13, 5, 6]\n// \n// FÃ¼ge 11 ein:\n// [11, 12, 13, 5, 6]\n// \n// FÃ¼ge 13 ein:\n// [11, 12, 13, 5, 6]\n// \n// FÃ¼ge 5 ein:\n// [5, 11, 12, 13, 6]\n// \n// FÃ¼ge 6 ein:\n// [5, 6, 11, 12, 13]",
      "explanation": "Insertion Sort ist besonders effizient fÃ¼r fast sortierte Listen. Die while-Schleife verschiebt grÃ¶ÃŸere Elemente nach rechts, bis die richtige Position fÃ¼r das einzufÃ¼gende Element gefunden ist."
    },
    {
      "language": "python",
      "title": "Vergleich aller drei Algorithmen mit Zeitmessung",
      "code": "import time\nimport random\n\ndef bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        swapped = False\n        for j in range(n - i - 1):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                swapped = True\n        if not swapped:\n            break\n    return arr\n\ndef selection_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        min_idx = i\n        for j in range(i + 1, n):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr\n\ndef insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr\n\n# Teste mit verschiedenen ListengrÃ¶ÃŸen\nsizes = [100, 500, 1000]\n\nfor size in sizes:\n    print(f\"\\n=== Liste mit {size} Elementen ===\")\n    \n    # Erstelle zufÃ¤llige Liste\n    original = [random.randint(1, 1000) for _ in range(size)]\n    \n    # Bubble Sort\n    arr = original.copy()\n    start = time.time()\n    bubble_sort(arr)\n    bubble_time = time.time() - start\n    print(f\"Bubble Sort:    {bubble_time:.4f} Sekunden\")\n    \n    # Selection Sort\n    arr = original.copy()\n    start = time.time()\n    selection_sort(arr)\n    selection_time = time.time() - start\n    print(f\"Selection Sort: {selection_time:.4f} Sekunden\")\n    \n    # Insertion Sort\n    arr = original.copy()\n    start = time.time()\n    insertion_sort(arr)\n    insertion_time = time.time() - start\n    print(f\"Insertion Sort: {insertion_time:.4f} Sekunden\")\n\n# Beispiel Output:\n# === Liste mit 100 Elementen ===\n# Bubble Sort:    0.0023 Sekunden\n# Selection Sort: 0.0015 Sekunden\n# Insertion Sort: 0.0012 Sekunden\n# \n# === Liste mit 500 Elementen ===\n# Bubble Sort:    0.0567 Sekunden\n# Selection Sort: 0.0389 Sekunden\n# Insertion Sort: 0.0298 Sekunden",
      "explanation": "Dieser Code vergleicht die Performance aller drei Algorithmen. Insertion Sort ist in der Praxis oft am schnellsten, gefolgt von Selection Sort und Bubble Sort."
    }
  ],
  "relatedQuizzes": ["sorting-algorithms-quiz"],
  "resources": [
    {
      "title": "Visualgo - Sortieralgorithmen visualisiert",
      "url": "https://visualgo.net/en/sorting",
      "type": "video"
    },
    {
      "title": "Big-O Cheat Sheet",
      "url": "https://www.bigocheatsheet.com/",
      "type": "article"
    }
  ],
  "lastUpdated": "2025-01-10T00:00:00Z",
  "version": "1.0"
}
