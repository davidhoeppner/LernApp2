{
  "id": "sql-comprehensive-quiz-2025",
  "moduleId": "sql-dql-2025",
  "title": "SQL Komplett-Quiz - IHK Prüfungsvorbereitung",
  "description": "Umfassendes Quiz zu allen SQL-Themen aus dem Prüfungsbeiblatt: DDL, DML und DQL. 20 Fragen mit ausführlichen Erklärungen.",
  "category": "FÜ-02",
  "difficulty": "intermediate",
  "examRelevance": "high",
  "newIn2025": true,
  "timeLimit": 35,
  "passingScore": 70,
  "questions": [
    {
      "id": "sql-q1",
      "type": "single-choice",
      "question": "Welcher SQL-Befehl wird verwendet, um eine neue Tabelle zu erstellen?",
      "options": [
        "CREATE TABLE",
        "NEW TABLE",
        "INSERT TABLE",
        "MAKE TABLE"
      ],
      "correctAnswer": "CREATE TABLE",
      "explanation": "CREATE TABLE ist der DDL-Befehl zum Erstellen neuer Tabellen. Die Syntax lautet: CREATE TABLE table_name (column1 datatype, column2 datatype, ...);",
      "points": 1,
      "category": "DDL"
    },
    {
      "id": "sql-q2",
      "type": "single-choice",
      "question": "Was bewirkt der Constraint PRIMARY KEY?",
      "options": [
        "Die Spalte darf NULL-Werte enthalten",
        "Die Spalte ist eindeutig und darf nicht NULL sein",
        "Die Spalte wird automatisch sortiert",
        "Die Spalte wird verschlüsselt"
      ],
      "correctAnswer": "Die Spalte ist eindeutig und darf nicht NULL sein",
      "explanation": "PRIMARY KEY kombiniert UNIQUE und NOT NULL. Jede Tabelle sollte einen Primärschlüssel haben, der jede Zeile eindeutig identifiziert.",
      "points": 1,
      "category": "DDL"
    },
    {
      "id": "sql-q3",
      "type": "code",
      "question": "Welcher Befehl fügt eine neue Spalte 'telefon' (VARCHAR(20)) zur Tabelle 'kunde' hinzu?",
      "code": "",
      "language": "sql",
      "options": [
        "ALTER TABLE kunde ADD telefon VARCHAR(20);",
        "UPDATE TABLE kunde ADD telefon VARCHAR(20);",
        "INSERT INTO kunde ADD telefon VARCHAR(20);",
        "MODIFY TABLE kunde ADD telefon VARCHAR(20);"
      ],
      "correctAnswer": "ALTER TABLE kunde ADD telefon VARCHAR(20);",
      "explanation": "ALTER TABLE wird verwendet, um die Struktur einer bestehenden Tabelle zu ändern. Mit ADD fügt man neue Spalten hinzu.",
      "points": 2,
      "category": "DDL"
    },
    {
      "id": "sql-q4",
      "type": "single-choice",
      "question": "Wozu dient ein INDEX in einer Datenbank?",
      "options": [
        "Um Daten zu verschlüsseln",
        "Um Abfragen zu beschleunigen",
        "Um Duplikate zu verhindern",
        "Um Daten zu komprimieren"
      ],
      "correctAnswer": "Um Abfragen zu beschleunigen",
      "explanation": "Ein Index funktioniert wie ein Inhaltsverzeichnis und beschleunigt SELECT-Abfragen erheblich. Nachteil: INSERT/UPDATE/DELETE werden langsamer und es wird mehr Speicherplatz benötigt.",
      "points": 1,
      "category": "DDL"
    },
    {
      "id": "sql-q5",
      "type": "code",
      "question": "Welcher Befehl erstellt einen Index auf der Spalte 'nachname' der Tabelle 'mitarbeiter'?",
      "code": "",
      "language": "sql",
      "options": [
        "CREATE INDEX idx_nachname ON mitarbeiter(nachname);",
        "ADD INDEX idx_nachname TO mitarbeiter(nachname);",
        "INSERT INDEX idx_nachname INTO mitarbeiter(nachname);",
        "NEW INDEX idx_nachname FOR mitarbeiter(nachname);"
      ],
      "correctAnswer": "CREATE INDEX idx_nachname ON mitarbeiter(nachname);",
      "explanation": "CREATE INDEX erstellt einen Index. Die Syntax: CREATE INDEX index_name ON table_name(column_name);",
      "points": 2,
      "category": "DDL"
    },
    {
      "id": "sql-q6",
      "type": "code",
      "question": "Welcher Befehl fügt einen neuen Kunden in die Tabelle 'kunde' ein?",
      "code": "",
      "language": "sql",
      "options": [
        "INSERT INTO kunde (kunde_id, name, email) VALUES (1, 'Max Müller', 'max@test.de');",
        "ADD INTO kunde (kunde_id, name, email) VALUES (1, 'Max Müller', 'max@test.de');",
        "CREATE kunde (kunde_id, name, email) VALUES (1, 'Max Müller', 'max@test.de');",
        "UPDATE kunde SET kunde_id=1, name='Max Müller', email='max@test.de';"
      ],
      "correctAnswer": "INSERT INTO kunde (kunde_id, name, email) VALUES (1, 'Max Müller', 'max@test.de');",
      "explanation": "INSERT INTO fügt neue Zeilen in eine Tabelle ein. Die Syntax: INSERT INTO table_name (columns) VALUES (values);",
      "points": 2,
      "category": "DML"
    },
    {
      "id": "sql-q7",
      "type": "single-choice",
      "question": "Was passiert, wenn man UPDATE ohne WHERE-Klausel verwendet?",
      "options": [
        "Es wird ein Fehler ausgegeben",
        "Nur die erste Zeile wird geändert",
        "ALLE Zeilen in der Tabelle werden geändert",
        "Nichts passiert"
      ],
      "correctAnswer": "ALLE Zeilen in der Tabelle werden geändert",
      "explanation": "Ohne WHERE-Klausel werden ALLE Zeilen betroffen! Dies ist ein häufiger und gefährlicher Fehler. Immer WHERE verwenden, außer man möchte wirklich alle Zeilen ändern.",
      "points": 2,
      "category": "DML"
    },
    {
      "id": "sql-q8",
      "type": "code",
      "question": "Wie erhöht man das Gehalt aller Mitarbeiter um 10%?",
      "code": "",
      "language": "sql",
      "options": [
        "UPDATE mitarbeiter SET gehalt = gehalt * 1.10;",
        "UPDATE mitarbeiter SET gehalt = gehalt + 10;",
        "INSERT INTO mitarbeiter SET gehalt = gehalt * 1.10;",
        "ALTER mitarbeiter SET gehalt = gehalt * 1.10;"
      ],
      "correctAnswer": "UPDATE mitarbeiter SET gehalt = gehalt * 1.10;",
      "explanation": "UPDATE mit Berechnung: gehalt * 1.10 erhöht um 10%. Ohne WHERE werden alle Zeilen geändert, was hier gewünscht ist.",
      "points": 2,
      "category": "DML"
    },
    {
      "id": "sql-q9",
      "type": "code",
      "question": "Welcher Befehl löscht alle Kunden mit kunde_id größer als 100?",
      "code": "",
      "language": "sql",
      "options": [
        "DELETE FROM kunde WHERE kunde_id > 100;",
        "REMOVE FROM kunde WHERE kunde_id > 100;",
        "DROP kunde WHERE kunde_id > 100;",
        "DELETE kunde WHERE kunde_id > 100;"
      ],
      "correctAnswer": "DELETE FROM kunde WHERE kunde_id > 100;",
      "explanation": "DELETE FROM löscht Zeilen aus einer Tabelle. Die WHERE-Klausel bestimmt, welche Zeilen gelöscht werden.",
      "points": 2,
      "category": "DML"
    },
    {
      "id": "sql-q10",
      "type": "single-choice",
      "question": "Was ist der Unterschied zwischen DELETE und TRUNCATE?",
      "options": [
        "Es gibt keinen Unterschied",
        "DELETE löscht die Struktur, TRUNCATE nur die Daten",
        "TRUNCATE ist schneller und löscht alle Zeilen ohne WHERE",
        "TRUNCATE kann rückgängig gemacht werden, DELETE nicht"
      ],
      "correctAnswer": "TRUNCATE ist schneller und löscht alle Zeilen ohne WHERE",
      "explanation": "TRUNCATE TABLE löscht alle Zeilen sehr schnell, kann aber keine WHERE-Klausel verwenden. DELETE ist langsamer, aber flexibler.",
      "points": 2,
      "category": "DML"
    },
    {
      "id": "sql-q11",
      "type": "code",
      "question": "Welche Abfrage wählt alle Spalten aus der Tabelle 'produkt' aus?",
      "code": "",
      "language": "sql",
      "options": [
        "SELECT * FROM produkt;",
        "GET * FROM produkt;",
        "SHOW * FROM produkt;",
        "FETCH * FROM produkt;"
      ],
      "correctAnswer": "SELECT * FROM produkt;",
      "explanation": "SELECT * wählt alle Spalten aus. In der Praxis sollte man aber nur die benötigten Spalten explizit angeben.",
      "points": 1,
      "category": "DQL"
    },
    {
      "id": "sql-q12",
      "type": "code",
      "question": "Wie filtert man Mitarbeiter mit einem Gehalt über 50000?",
      "code": "",
      "language": "sql",
      "options": [
        "SELECT * FROM mitarbeiter WHERE gehalt > 50000;",
        "SELECT * FROM mitarbeiter FILTER gehalt > 50000;",
        "SELECT * FROM mitarbeiter IF gehalt > 50000;",
        "SELECT * FROM mitarbeiter HAVING gehalt > 50000;"
      ],
      "correctAnswer": "SELECT * FROM mitarbeiter WHERE gehalt > 50000;",
      "explanation": "WHERE filtert Zeilen vor der Gruppierung. Die Syntax: WHERE column operator value;",
      "points": 1,
      "category": "DQL"
    },
    {
      "id": "sql-q13",
      "type": "code",
      "question": "Wie prüft man auf NULL-Werte in SQL?",
      "code": "",
      "language": "sql",
      "options": [
        "WHERE spalte IS NULL",
        "WHERE spalte = NULL",
        "WHERE spalte == NULL",
        "WHERE spalte EQUALS NULL"
      ],
      "correctAnswer": "WHERE spalte IS NULL",
      "explanation": "Verwende immer IS NULL oder IS NOT NULL. Der Vergleich mit = NULL funktioniert nicht, da NULL 'unbekannt' bedeutet.",
      "points": 2,
      "category": "DQL"
    },
    {
      "id": "sql-q14",
      "type": "code",
      "question": "Wie sortiert man Mitarbeiter nach Gehalt absteigend?",
      "code": "",
      "language": "sql",
      "options": [
        "SELECT * FROM mitarbeiter ORDER BY gehalt DESC;",
        "SELECT * FROM mitarbeiter SORT BY gehalt DESC;",
        "SELECT * FROM mitarbeiter ORDER gehalt DESC;",
        "SELECT * FROM mitarbeiter GROUP BY gehalt DESC;"
      ],
      "correctAnswer": "SELECT * FROM mitarbeiter ORDER BY gehalt DESC;",
      "explanation": "ORDER BY sortiert das Ergebnis. DESC = absteigend (descending), ASC = aufsteigend (ascending, Standard).",
      "points": 1,
      "category": "DQL"
    },
    {
      "id": "sql-q15",
      "type": "code",
      "question": "Wie zählt man die Anzahl Mitarbeiter pro Abteilung?",
      "code": "",
      "language": "sql",
      "options": [
        "SELECT abteilung_id, COUNT(*) FROM mitarbeiter GROUP BY abteilung_id;",
        "SELECT abteilung_id, COUNT(*) FROM mitarbeiter;",
        "SELECT COUNT(*) FROM mitarbeiter WHERE abteilung_id;",
        "SELECT abteilung_id, SUM(*) FROM mitarbeiter GROUP BY abteilung_id;"
      ],
      "correctAnswer": "SELECT abteilung_id, COUNT(*) FROM mitarbeiter GROUP BY abteilung_id;",
      "explanation": "GROUP BY gruppiert Zeilen. Alle Spalten im SELECT (außer Aggregatfunktionen) müssen auch in GROUP BY stehen.",
      "points": 2,
      "category": "DQL"
    },
    {
      "id": "sql-q16",
      "type": "single-choice",
      "question": "Was ist der Unterschied zwischen WHERE und HAVING?",
      "options": [
        "Es gibt keinen Unterschied",
        "WHERE filtert vor GROUP BY, HAVING filtert nach GROUP BY",
        "WHERE ist für Zahlen, HAVING für Text",
        "HAVING ist schneller als WHERE"
      ],
      "correctAnswer": "WHERE filtert vor GROUP BY, HAVING filtert nach GROUP BY",
      "explanation": "WHERE filtert einzelne Zeilen vor der Gruppierung. HAVING filtert Gruppen nach der Gruppierung und kann Aggregatfunktionen verwenden.",
      "points": 2,
      "category": "DQL"
    },
    {
      "id": "sql-q17",
      "type": "single-choice",
      "question": "Was macht ein INNER JOIN?",
      "options": [
        "Gibt alle Zeilen aus beiden Tabellen zurück",
        "Gibt nur Zeilen zurück, die in beiden Tabellen übereinstimmen",
        "Gibt alle Zeilen aus der linken Tabelle zurück",
        "Gibt alle Zeilen aus der rechten Tabelle zurück"
      ],
      "correctAnswer": "Gibt nur Zeilen zurück, die in beiden Tabellen übereinstimmen",
      "explanation": "INNER JOIN gibt nur Zeilen zurück, wo die JOIN-Bedingung erfüllt ist. Zeilen ohne Übereinstimmung werden ausgeschlossen.",
      "points": 2,
      "category": "DQL"
    },
    {
      "id": "sql-q18",
      "type": "single-choice",
      "question": "Was ist der Unterschied zwischen INNER JOIN und LEFT JOIN?",
      "options": [
        "Es gibt keinen Unterschied",
        "LEFT JOIN gibt auch Zeilen aus der linken Tabelle zurück, die keine Übereinstimmung haben",
        "LEFT JOIN ist schneller",
        "INNER JOIN kann nur zwei Tabellen verknüpfen"
      ],
      "correctAnswer": "LEFT JOIN gibt auch Zeilen aus der linken Tabelle zurück, die keine Übereinstimmung haben",
      "explanation": "LEFT JOIN (oder LEFT OUTER JOIN) behält alle Zeilen der linken Tabelle. Fehlende Werte aus der rechten Tabelle werden als NULL dargestellt.",
      "points": 2,
      "category": "DQL"
    },
    {
      "id": "sql-q19",
      "type": "single-choice",
      "question": "In welcher Reihenfolge werden SQL-Befehle ausgeführt?",
      "options": [
        "SELECT → FROM → WHERE → GROUP BY → HAVING → ORDER BY",
        "FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY",
        "FROM → SELECT → WHERE → GROUP BY → ORDER BY → HAVING",
        "SELECT → WHERE → FROM → GROUP BY → HAVING → ORDER BY"
      ],
      "correctAnswer": "FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY",
      "explanation": "Ausführungsreihenfolge: 1. FROM (Tabellen laden), 2. WHERE (Zeilen filtern), 3. GROUP BY (Gruppieren), 4. HAVING (Gruppen filtern), 5. SELECT (Spalten auswählen), 6. ORDER BY (Sortieren), 7. LIMIT (Begrenzen).",
      "points": 2,
      "category": "DQL"
    },
    {
      "id": "sql-q20",
      "type": "code",
      "question": "Wie findet man alle Mitarbeiter, deren Nachname mit 'M' beginnt?",
      "code": "",
      "language": "sql",
      "options": [
        "SELECT * FROM mitarbeiter WHERE nachname LIKE 'M%';",
        "SELECT * FROM mitarbeiter WHERE nachname = 'M%';",
        "SELECT * FROM mitarbeiter WHERE nachname STARTS WITH 'M';",
        "SELECT * FROM mitarbeiter WHERE nachname[0] = 'M';"
      ],
      "correctAnswer": "SELECT * FROM mitarbeiter WHERE nachname LIKE 'M%';",
      "explanation": "LIKE mit % für Mustersuche. 'M%' = beginnt mit M, '%M' = endet mit M, '%M%' = enthält M. Der Unterstrich _ steht für genau ein Zeichen.",
      "points": 1,
      "category": "DQL"
    }
  ],
  "tags": ["SQL", "DDL", "DML", "DQL", "IHK", "Prüfung", "Datenbank"],
  "lastUpdated": "2025-01-05T12:00:00Z"
}
