{
  "id": "sql-comprehensive-quiz-2025",
  "moduleId": "sql-dql-2025",
  "title": "SQL Komplett-Quiz - IHK Prüfungsvorbereitung",
  "description": "Umfassendes Quiz zu allen SQL-Themen aus dem Prüfungsbeiblatt: DDL, DML und DQL. 35 Fragen mit ausführlichen Erklärungen.",
  "category": "FÜ-02",
  "difficulty": "intermediate",
  "examRelevance": "high",
  "newIn2025": true,
  "timeLimit": 60,
  "passingScore": 70,
  "questions": [
    {
      "id": "sql-q1",
      "type": "single-choice",
      "question": "Welcher SQL-Befehl wird verwendet, um eine neue Tabelle zu erstellen?",
      "options": [
        "CREATE TABLE",
        "NEW TABLE",
        "INSERT TABLE",
        "MAKE TABLE"
      ],
      "correctAnswer": "CREATE TABLE",
      "explanation": "CREATE TABLE ist der DDL-Befehl zum Erstellen neuer Tabellen. Die Syntax lautet: CREATE TABLE table_name (column1 datatype, column2 datatype, ...);",
      "points": 1,
      "category": "DDL"
    },
    {
      "id": "sql-q2",
      "type": "single-choice",
      "question": "Was bewirkt der Constraint PRIMARY KEY?",
      "options": [
        "Die Spalte darf NULL-Werte enthalten",
        "Die Spalte ist eindeutig und darf nicht NULL sein",
        "Die Spalte wird automatisch sortiert",
        "Die Spalte wird verschlüsselt"
      ],
      "correctAnswer": "Die Spalte ist eindeutig und darf nicht NULL sein",
      "explanation": "PRIMARY KEY kombiniert UNIQUE und NOT NULL. Jede Tabelle sollte einen Primärschlüssel haben, der jede Zeile eindeutig identifiziert.",
      "points": 1,
      "category": "DDL"
    },
    {
      "id": "sql-q3",
      "type": "code",
      "question": "Welcher Befehl fügt eine neue Spalte 'telefon' (VARCHAR(20)) zur Tabelle 'kunde' hinzu?",
      "code": "",
      "language": "sql",
      "options": [
        "ALTER TABLE kunde ADD telefon VARCHAR(20);",
        "UPDATE TABLE kunde ADD telefon VARCHAR(20);",
        "INSERT INTO kunde ADD telefon VARCHAR(20);",
        "MODIFY TABLE kunde ADD telefon VARCHAR(20);"
      ],
      "correctAnswer": "ALTER TABLE kunde ADD telefon VARCHAR(20);",
      "explanation": "ALTER TABLE wird verwendet, um die Struktur einer bestehenden Tabelle zu ändern. Mit ADD fügt man neue Spalten hinzu.",
      "points": 2,
      "category": "DDL"
    },
    {
      "id": "sql-q4",
      "type": "single-choice",
      "question": "Wozu dient ein INDEX in einer Datenbank?",
      "options": [
        "Um Daten zu verschlüsseln",
        "Um Abfragen zu beschleunigen",
        "Um Duplikate zu verhindern",
        "Um Daten zu komprimieren"
      ],
      "correctAnswer": "Um Abfragen zu beschleunigen",
      "explanation": "Ein Index funktioniert wie ein Inhaltsverzeichnis und beschleunigt SELECT-Abfragen erheblich. Nachteil: INSERT/UPDATE/DELETE werden langsamer und es wird mehr Speicherplatz benötigt.",
      "points": 1,
      "category": "DDL"
    },
    {
      "id": "sql-q5",
      "type": "code",
      "question": "Welcher Befehl erstellt einen Index auf der Spalte 'nachname' der Tabelle 'mitarbeiter'?",
      "code": "",
      "language": "sql",
      "options": [
        "CREATE INDEX idx_nachname ON mitarbeiter(nachname);",
        "ADD INDEX idx_nachname TO mitarbeiter(nachname);",
        "INSERT INDEX idx_nachname INTO mitarbeiter(nachname);",
        "NEW INDEX idx_nachname FOR mitarbeiter(nachname);"
      ],
      "correctAnswer": "CREATE INDEX idx_nachname ON mitarbeiter(nachname);",
      "explanation": "CREATE INDEX erstellt einen Index. Die Syntax: CREATE INDEX index_name ON table_name(column_name);",
      "points": 2,
      "category": "DDL"
    },
    {
      "id": "sql-q6",
      "type": "code",
      "question": "Welcher Befehl fügt einen neuen Kunden in die Tabelle 'kunde' ein?",
      "code": "",
      "language": "sql",
      "options": [
        "INSERT INTO kunde (kunde_id, name, email) VALUES (1, 'Max Müller', 'max@test.de');",
        "ADD INTO kunde (kunde_id, name, email) VALUES (1, 'Max Müller', 'max@test.de');",
        "CREATE kunde (kunde_id, name, email) VALUES (1, 'Max Müller', 'max@test.de');",
        "UPDATE kunde SET kunde_id=1, name='Max Müller', email='max@test.de';"
      ],
      "correctAnswer": "INSERT INTO kunde (kunde_id, name, email) VALUES (1, 'Max Müller', 'max@test.de');",
      "explanation": "INSERT INTO fügt neue Zeilen in eine Tabelle ein. Die Syntax: INSERT INTO table_name (columns) VALUES (values);",
      "points": 2,
      "category": "DML"
    },
    {
      "id": "sql-q7",
      "type": "single-choice",
      "question": "Was passiert, wenn man UPDATE ohne WHERE-Klausel verwendet?",
      "options": [
        "Es wird ein Fehler ausgegeben",
        "Nur die erste Zeile wird geändert",
        "ALLE Zeilen in der Tabelle werden geändert",
        "Nichts passiert"
      ],
      "correctAnswer": "ALLE Zeilen in der Tabelle werden geändert",
      "explanation": "Ohne WHERE-Klausel werden ALLE Zeilen betroffen! Dies ist ein häufiger und gefährlicher Fehler. Immer WHERE verwenden, außer man möchte wirklich alle Zeilen ändern.",
      "points": 2,
      "category": "DML"
    },
    {
      "id": "sql-q8",
      "type": "code",
      "question": "Wie erhöht man das Gehalt aller Mitarbeiter um 10%?",
      "code": "",
      "language": "sql",
      "options": [
        "UPDATE mitarbeiter SET gehalt = gehalt * 1.10;",
        "UPDATE mitarbeiter SET gehalt = gehalt + 10;",
        "INSERT INTO mitarbeiter SET gehalt = gehalt * 1.10;",
        "ALTER mitarbeiter SET gehalt = gehalt * 1.10;"
      ],
      "correctAnswer": "UPDATE mitarbeiter SET gehalt = gehalt * 1.10;",
      "explanation": "UPDATE mit Berechnung: gehalt * 1.10 erhöht um 10%. Ohne WHERE werden alle Zeilen geändert, was hier gewünscht ist.",
      "points": 2,
      "category": "DML"
    },
    {
      "id": "sql-q9",
      "type": "code",
      "question": "Welcher Befehl löscht alle Kunden mit kunde_id größer als 100?",
      "code": "",
      "language": "sql",
      "options": [
        "DELETE FROM kunde WHERE kunde_id > 100;",
        "REMOVE FROM kunde WHERE kunde_id > 100;",
        "DROP kunde WHERE kunde_id > 100;",
        "DELETE kunde WHERE kunde_id > 100;"
      ],
      "correctAnswer": "DELETE FROM kunde WHERE kunde_id > 100;",
      "explanation": "DELETE FROM löscht Zeilen aus einer Tabelle. Die WHERE-Klausel bestimmt, welche Zeilen gelöscht werden.",
      "points": 2,
      "category": "DML"
    },
    {
      "id": "sql-q10",
      "type": "single-choice",
      "question": "Was ist der Unterschied zwischen DELETE und TRUNCATE?",
      "options": [
        "Es gibt keinen Unterschied",
        "DELETE löscht die Struktur, TRUNCATE nur die Daten",
        "TRUNCATE ist schneller und löscht alle Zeilen ohne WHERE",
        "TRUNCATE kann rückgängig gemacht werden, DELETE nicht"
      ],
      "correctAnswer": "TRUNCATE ist schneller und löscht alle Zeilen ohne WHERE",
      "explanation": "TRUNCATE TABLE löscht alle Zeilen sehr schnell, kann aber keine WHERE-Klausel verwenden. DELETE ist langsamer, aber flexibler.",
      "points": 2,
      "category": "DML"
    },
    {
      "id": "sql-q11",
      "type": "code",
      "question": "Welche Abfrage wählt alle Spalten aus der Tabelle 'produkt' aus?",
      "code": "",
      "language": "sql",
      "options": [
        "SELECT * FROM produkt;",
        "GET * FROM produkt;",
        "SHOW * FROM produkt;",
        "FETCH * FROM produkt;"
      ],
      "correctAnswer": "SELECT * FROM produkt;",
      "explanation": "SELECT * wählt alle Spalten aus. In der Praxis sollte man aber nur die benötigten Spalten explizit angeben.",
      "points": 1,
      "category": "DQL"
    },
    {
      "id": "sql-q12",
      "type": "code",
      "question": "Wie filtert man Mitarbeiter mit einem Gehalt über 50000?",
      "code": "",
      "language": "sql",
      "options": [
        "SELECT * FROM mitarbeiter WHERE gehalt > 50000;",
        "SELECT * FROM mitarbeiter FILTER gehalt > 50000;",
        "SELECT * FROM mitarbeiter IF gehalt > 50000;",
        "SELECT * FROM mitarbeiter HAVING gehalt > 50000;"
      ],
      "correctAnswer": "SELECT * FROM mitarbeiter WHERE gehalt > 50000;",
      "explanation": "WHERE filtert Zeilen vor der Gruppierung. Die Syntax: WHERE column operator value;",
      "points": 1,
      "category": "DQL"
    },
    {
      "id": "sql-q13",
      "type": "single-choice",
      "question": "Was bedeutet das Prozentzeichen (%) im LIKE-Operator?",
      "options": [
        "Genau ein beliebiges Zeichen",
        "Beliebig viele Zeichen (auch null)",
        "Ein Prozentzeichen",
        "Eine Zahl"
      ],
      "correctAnswer": "Beliebig viele Zeichen (auch null)",
      "explanation": "% steht für beliebig viele Zeichen. Beispiel: 'M%' findet 'Müller', 'Meyer', 'M'. Der Unterstrich _ steht für genau ein Zeichen.",
      "points": 1,
      "category": "DQL"
    },
    {
      "id": "sql-q14",
      "type": "code",
      "question": "Wie prüft man auf NULL-Werte in SQL?",
      "code": "",
      "language": "sql",
      "options": [
        "WHERE spalte IS NULL",
        "WHERE spalte = NULL",
        "WHERE spalte == NULL",
        "WHERE spalte EQUALS NULL"
      ],
      "correctAnswer": "WHERE spalte IS NULL",
      "explanation": "Verwende immer IS NULL oder IS NOT NULL. Der Vergleich mit = NULL funktioniert nicht, da NULL 'unbekannt' bedeutet.",
      "points": 2,
      "category": "DQL"
    },
    {
      "id": "sql-q15",
      "type": "code",
      "question": "Wie sortiert man Mitarbeiter nach Gehalt absteigend?",
      "code": "",
      "language": "sql",
      "options": [
        "SELECT * FROM mitarbeiter ORDER BY gehalt DESC;",
        "SELECT * FROM mitarbeiter SORT BY gehalt DESC;",
        "SELECT * FROM mitarbeiter ORDER gehalt DESC;",
        "SELECT * FROM mitarbeiter GROUP BY gehalt DESC;"
      ],
      "correctAnswer": "SELECT * FROM mitarbeiter ORDER BY gehalt DESC;",
      "explanation": "ORDER BY sortiert das Ergebnis. DESC = absteigend (descending), ASC = aufsteigend (ascending, Standard).",
      "points": 1,
      "category": "DQL"
    },
    {
      "id": "sql-q16",
      "type": "single-choice",
      "question": "Welche Aggregatfunktion zählt die Anzahl der Zeilen?",
      "options": [
        "COUNT(*)",
        "SUM(*)",
        "TOTAL(*)",
        "NUMBER(*)"
      ],
      "correctAnswer": "COUNT(*)",
      "explanation": "COUNT(*) zählt alle Zeilen. COUNT(spalte) zählt nur Nicht-NULL-Werte. COUNT(DISTINCT spalte) zählt eindeutige Werte.",
      "points": 1,
      "category": "DQL"
    },
    {
      "id": "sql-q17",
      "type": "code",
      "question": "Wie berechnet man das durchschnittliche Gehalt aller Mitarbeiter?",
      "code": "",
      "language": "sql",
      "options": [
        "SELECT AVG(gehalt) FROM mitarbeiter;",
        "SELECT AVERAGE(gehalt) FROM mitarbeiter;",
        "SELECT MEAN(gehalt) FROM mitarbeiter;",
        "SELECT SUM(gehalt) / COUNT(*) FROM mitarbeiter;"
      ],
      "correctAnswer": "SELECT AVG(gehalt) FROM mitarbeiter;",
      "explanation": "AVG() berechnet den Durchschnitt. Andere Aggregatfunktionen: SUM(), MIN(), MAX(), COUNT(). Option 4 würde auch funktionieren, ist aber umständlich.",
      "points": 1,
      "category": "DQL"
    },
    {
      "id": "sql-q18",
      "type": "code",
      "question": "Wie zählt man die Anzahl Mitarbeiter pro Abteilung?",
      "code": "",
      "language": "sql",
      "options": [
        "SELECT abteilung_id, COUNT(*) FROM mitarbeiter GROUP BY abteilung_id;",
        "SELECT abteilung_id, COUNT(*) FROM mitarbeiter;",
        "SELECT COUNT(*) FROM mitarbeiter WHERE abteilung_id;",
        "SELECT abteilung_id, SUM(*) FROM mitarbeiter GROUP BY abteilung_id;"
      ],
      "correctAnswer": "SELECT abteilung_id, COUNT(*) FROM mitarbeiter GROUP BY abteilung_id;",
      "explanation": "GROUP BY gruppiert Zeilen. Alle Spalten im SELECT (außer Aggregatfunktionen) müssen auch in GROUP BY stehen.",
      "points": 2,
      "category": "DQL"
    },
    {
      "id": "sql-q19",
      "type": "single-choice",
      "question": "Was ist der Unterschied zwischen WHERE und HAVING?",
      "options": [
        "Es gibt keinen Unterschied",
        "WHERE filtert vor GROUP BY, HAVING filtert nach GROUP BY",
        "WHERE ist für Zahlen, HAVING für Text",
        "HAVING ist schneller als WHERE"
      ],
      "correctAnswer": "WHERE filtert vor GROUP BY, HAVING filtert nach GROUP BY",
      "explanation": "WHERE filtert einzelne Zeilen vor der Gruppierung. HAVING filtert Gruppen nach der Gruppierung und kann Aggregatfunktionen verwenden.",
      "points": 2,
      "category": "DQL"
    },
    {
      "id": "sql-q20",
      "type": "code",
      "question": "Wie findet man Abteilungen mit mehr als 5 Mitarbeitern?",
      "code": "",
      "language": "sql",
      "options": [
        "SELECT abteilung_id, COUNT(*) FROM mitarbeiter GROUP BY abteilung_id HAVING COUNT(*) > 5;",
        "SELECT abteilung_id, COUNT(*) FROM mitarbeiter WHERE COUNT(*) > 5 GROUP BY abteilung_id;",
        "SELECT abteilung_id FROM mitarbeiter WHERE COUNT(*) > 5;",
        "SELECT abteilung_id, COUNT(*) FROM mitarbeiter GROUP BY abteilung_id WHERE COUNT(*) > 5;"
      ],
      "correctAnswer": "SELECT abteilung_id, COUNT(*) FROM mitarbeiter GROUP BY abteilung_id HAVING COUNT(*) > 5;",
      "explanation": "HAVING wird verwendet, um Gruppen zu filtern. WHERE kann keine Aggregatfunktionen verwenden. Die Reihenfolge ist: WHERE → GROUP BY → HAVING.",
      "points": 2,
      "category": "DQL"
    },
    {
      "id": "sql-q21",
      "type": "single-choice",
      "question": "Was macht ein INNER JOIN?",
      "options": [
        "Gibt alle Zeilen aus beiden Tabellen zurück",
        "Gibt nur Zeilen zurück, die in beiden Tabellen übereinstimmen",
        "Gibt alle Zeilen aus der linken Tabelle zurück",
        "Gibt alle Zeilen aus der rechten Tabelle zurück"
      ],
      "correctAnswer": "Gibt nur Zeilen zurück, die in beiden Tabellen übereinstimmen",
      "explanation": "INNER JOIN gibt nur Zeilen zurück, wo die JOIN-Bedingung erfüllt ist. Zeilen ohne Übereinstimmung werden ausgeschlossen.",
      "points": 2,
      "category": "DQL"
    },
    {
      "id": "sql-q22",
      "type": "code",
      "question": "Wie verknüpft man Mitarbeiter mit ihren Abteilungen?",
      "code": "",
      "language": "sql",
      "options": [
        "SELECT m.*, a.name FROM mitarbeiter m INNER JOIN abteilung a ON m.abteilung_id = a.abteilung_id;",
        "SELECT m.*, a.name FROM mitarbeiter m, abteilung a WHERE m.abteilung_id = a.abteilung_id;",
        "SELECT m.*, a.name FROM mitarbeiter m JOIN abteilung a USING (abteilung_id);",
        "Alle Antworten sind korrekt"
      ],
      "correctAnswer": "Alle Antworten sind korrekt",
      "explanation": "Alle drei Syntaxen funktionieren. Die erste (INNER JOIN ... ON) ist am gebräuchlichsten und klarsten. Die zweite ist alte Syntax. Die dritte (USING) funktioniert nur, wenn die Spalten gleich heißen.",
      "points": 2,
      "category": "DQL"
    },
    {
      "id": "sql-q23",
      "type": "single-choice",
      "question": "Was ist der Unterschied zwischen INNER JOIN und LEFT JOIN?",
      "options": [
        "Es gibt keinen Unterschied",
        "LEFT JOIN gibt auch Zeilen aus der linken Tabelle zurück, die keine Übereinstimmung haben",
        "LEFT JOIN ist schneller",
        "INNER JOIN kann nur zwei Tabellen verknüpfen"
      ],
      "correctAnswer": "LEFT JOIN gibt auch Zeilen aus der linken Tabelle zurück, die keine Übereinstimmung haben",
      "explanation": "LEFT JOIN (oder LEFT OUTER JOIN) behält alle Zeilen der linken Tabelle. Fehlende Werte aus der rechten Tabelle werden als NULL dargestellt.",
      "points": 2,
      "category": "DQL"
    },
    {
      "id": "sql-q24",
      "type": "code",
      "question": "Was macht diese Abfrage?\n\nSELECT * FROM mitarbeiter WHERE gehalt > (SELECT AVG(gehalt) FROM mitarbeiter);",
      "code": "SELECT * FROM mitarbeiter WHERE gehalt > (SELECT AVG(gehalt) FROM mitarbeiter);",
      "language": "sql",
      "options": [
        "Findet Mitarbeiter mit überdurchschnittlichem Gehalt",
        "Findet Mitarbeiter mit dem höchsten Gehalt",
        "Berechnet das Durchschnittsgehalt",
        "Gibt einen Fehler aus"
      ],
      "correctAnswer": "Findet Mitarbeiter mit überdurchschnittlichem Gehalt",
      "explanation": "Die Subquery (SELECT AVG(gehalt) FROM mitarbeiter) berechnet zuerst den Durchschnitt. Dann werden alle Mitarbeiter gefunden, deren Gehalt größer ist.",
      "points": 2,
      "category": "DQL"
    },
    {
      "id": "sql-q25",
      "type": "code",
      "question": "Wie findet man Mitarbeiter aus Abteilungen in Berlin?",
      "code": "",
      "language": "sql",
      "options": [
        "SELECT * FROM mitarbeiter WHERE abteilung_id IN (SELECT abteilung_id FROM abteilung WHERE standort = 'Berlin');",
        "SELECT * FROM mitarbeiter WHERE standort = 'Berlin';",
        "SELECT * FROM mitarbeiter, abteilung WHERE standort = 'Berlin';",
        "SELECT * FROM mitarbeiter HAVING standort = 'Berlin';"
      ],
      "correctAnswer": "SELECT * FROM mitarbeiter WHERE abteilung_id IN (SELECT abteilung_id FROM abteilung WHERE standort = 'Berlin');",
      "explanation": "Die Subquery findet zuerst alle Abteilungs-IDs in Berlin. Dann werden Mitarbeiter mit diesen IDs gefunden. Alternative: JOIN verwenden.",
      "points": 2,
      "category": "DQL"
    },
    {
      "id": "sql-q26",
      "type": "single-choice",
      "question": "Was macht DISTINCT?",
      "options": [
        "Sortiert das Ergebnis",
        "Entfernt Duplikate aus dem Ergebnis",
        "Zählt die Zeilen",
        "Gruppiert die Zeilen"
      ],
      "correctAnswer": "Entfernt Duplikate aus dem Ergebnis",
      "explanation": "DISTINCT entfernt doppelte Zeilen aus dem Ergebnis. Beispiel: SELECT DISTINCT abteilung_id FROM mitarbeiter; gibt jede Abteilungs-ID nur einmal zurück.",
      "points": 1,
      "category": "DQL"
    },
    {
      "id": "sql-q27",
      "type": "code",
      "question": "Wie begrenzt man das Ergebnis auf die ersten 10 Zeilen?",
      "code": "",
      "language": "sql",
      "options": [
        "SELECT * FROM mitarbeiter LIMIT 10;",
        "SELECT TOP 10 * FROM mitarbeiter;",
        "SELECT * FROM mitarbeiter WHERE ROWNUM <= 10;",
        "Alle Antworten können je nach DBMS korrekt sein"
      ],
      "correctAnswer": "Alle Antworten können je nach DBMS korrekt sein",
      "explanation": "LIMIT 10 (MySQL, PostgreSQL), TOP 10 (SQL Server), ROWNUM <= 10 (Oracle). Im IHK-Beiblatt steht LIMIT, also ist das die bevorzugte Antwort.",
      "points": 2,
      "category": "DQL"
    },
    {
      "id": "sql-q28",
      "type": "code",
      "question": "Was ist falsch an dieser Abfrage?\n\nSELECT abteilung_id, vorname, COUNT(*) FROM mitarbeiter GROUP BY abteilung_id;",
      "code": "SELECT abteilung_id, vorname, COUNT(*) FROM mitarbeiter GROUP BY abteilung_id;",
      "language": "sql",
      "options": [
        "vorname muss auch in GROUP BY stehen oder eine Aggregatfunktion sein",
        "COUNT(*) ist falsch",
        "GROUP BY ist falsch platziert",
        "Die Abfrage ist korrekt"
      ],
      "correctAnswer": "vorname muss auch in GROUP BY stehen oder eine Aggregatfunktion sein",
      "explanation": "Alle Spalten im SELECT (außer Aggregatfunktionen) müssen auch in GROUP BY stehen. Sonst ist unklar, welcher Vorname pro Gruppe angezeigt werden soll.",
      "points": 2,
      "category": "DQL"
    },
    {
      "id": "sql-q29",
      "type": "code",
      "question": "Wie findet man die 3 bestbezahlten Mitarbeiter?",
      "code": "",
      "language": "sql",
      "options": [
        "SELECT * FROM mitarbeiter ORDER BY gehalt DESC LIMIT 3;",
        "SELECT TOP 3 * FROM mitarbeiter ORDER BY gehalt DESC;",
        "SELECT * FROM mitarbeiter WHERE gehalt IN (SELECT TOP 3 gehalt FROM mitarbeiter);",
        "Option 1 und 2 sind korrekt (je nach DBMS)"
      ],
      "correctAnswer": "Option 1 und 2 sind korrekt (je nach DBMS)",
      "explanation": "Erst nach Gehalt absteigend sortieren, dann auf 3 Zeilen begrenzen. LIMIT (MySQL/PostgreSQL) oder TOP (SQL Server).",
      "points": 2,
      "category": "DQL"
    },
    {
      "id": "sql-q30",
      "type": "single-choice",
      "question": "In welcher Reihenfolge werden SQL-Befehle ausgeführt?",
      "options": [
        "SELECT → FROM → WHERE → GROUP BY → HAVING → ORDER BY",
        "FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY",
        "FROM → SELECT → WHERE → GROUP BY → ORDER BY → HAVING",
        "SELECT → WHERE → FROM → GROUP BY → HAVING → ORDER BY"
      ],
      "correctAnswer": "FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY",
      "explanation": "Ausführungsreihenfolge: 1. FROM (Tabellen laden), 2. WHERE (Zeilen filtern), 3. GROUP BY (Gruppieren), 4. HAVING (Gruppen filtern), 5. SELECT (Spalten auswählen), 6. ORDER BY (Sortieren), 7. LIMIT (Begrenzen).",
      "points": 2,
      "category": "DQL"
    },
    {
      "id": "sql-q31",
      "type": "code",
      "question": "Was gibt diese Abfrage zurück?\n\nSELECT COUNT(DISTINCT abteilung_id) FROM mitarbeiter;",
      "code": "SELECT COUNT(DISTINCT abteilung_id) FROM mitarbeiter;",
      "language": "sql",
      "options": [
        "Die Anzahl verschiedener Abteilungen",
        "Die Anzahl aller Mitarbeiter",
        "Die Anzahl der Abteilungen mit Mitarbeitern",
        "Option 1 und 3 sind beide korrekt"
      ],
      "correctAnswer": "Option 1 und 3 sind beide korrekt",
      "explanation": "COUNT(DISTINCT spalte) zählt die Anzahl eindeutiger Nicht-NULL-Werte. Dies entspricht der Anzahl verschiedener Abteilungen, die mindestens einen Mitarbeiter haben.",
      "points": 2,
      "category": "DQL"
    },
    {
      "id": "sql-q32",
      "type": "code",
      "question": "Welche Abfrage findet Mitarbeiter ohne Abteilung?",
      "code": "",
      "language": "sql",
      "options": [
        "SELECT * FROM mitarbeiter WHERE abteilung_id IS NULL;",
        "SELECT * FROM mitarbeiter WHERE abteilung_id = NULL;",
        "SELECT * FROM mitarbeiter WHERE NOT abteilung_id;",
        "SELECT * FROM mitarbeiter WHERE abteilung_id = '';"
      ],
      "correctAnswer": "SELECT * FROM mitarbeiter WHERE abteilung_id IS NULL;",
      "explanation": "Verwende immer IS NULL für NULL-Prüfungen. Der Vergleich mit = NULL funktioniert nicht. Option 4 prüft auf leeren String, nicht auf NULL.",
      "points": 2,
      "category": "DQL"
    },
    {
      "id": "sql-q33",
      "type": "code",
      "question": "Wie berechnet man das Jahresgehalt (Monatsgehalt * 12) in einer Abfrage?",
      "code": "",
      "language": "sql",
      "options": [
        "SELECT vorname, nachname, gehalt * 12 AS jahresgehalt FROM mitarbeiter;",
        "SELECT vorname, nachname, SUM(gehalt * 12) FROM mitarbeiter;",
        "SELECT vorname, nachname, gehalt + 12 AS jahresgehalt FROM mitarbeiter;",
        "SELECT vorname, nachname, MULTIPLY(gehalt, 12) FROM mitarbeiter;"
      ],
      "correctAnswer": "SELECT vorname, nachname, gehalt * 12 AS jahresgehalt FROM mitarbeiter;",
      "explanation": "Berechnungen können direkt im SELECT durchgeführt werden. AS gibt der berechneten Spalte einen Alias-Namen.",
      "points": 1,
      "category": "DQL"
    },
    {
      "id": "sql-q34",
      "type": "code",
      "question": "Wie findet man alle Mitarbeiter, deren Nachname mit 'M' beginnt?",
      "code": "",
      "language": "sql",
      "options": [
        "SELECT * FROM mitarbeiter WHERE nachname LIKE 'M%';",
        "SELECT * FROM mitarbeiter WHERE nachname = 'M%';",
        "SELECT * FROM mitarbeiter WHERE nachname STARTS WITH 'M';",
        "SELECT * FROM mitarbeiter WHERE nachname[0] = 'M';"
      ],
      "correctAnswer": "SELECT * FROM mitarbeiter WHERE nachname LIKE 'M%';",
      "explanation": "LIKE mit % für Mustersuche. 'M%' = beginnt mit M, '%M' = endet mit M, '%M%' = enthält M. Der Unterstrich _ steht für genau ein Zeichen.",
      "points": 1,
      "category": "DQL"
    },
    {
      "id": "sql-q35",
      "type": "code",
      "question": "Was macht diese komplexe Abfrage?\n\nSELECT a.name, COUNT(m.mitarbeiter_id) AS anzahl\nFROM abteilung a\nLEFT JOIN mitarbeiter m ON a.abteilung_id = m.abteilung_id\nGROUP BY a.abteilung_id, a.name\nHAVING COUNT(m.mitarbeiter_id) > 0\nORDER BY anzahl DESC;",
      "code": "SELECT a.name, COUNT(m.mitarbeiter_id) AS anzahl\nFROM abteilung a\nLEFT JOIN mitarbeiter m ON a.abteilung_id = m.abteilung_id\nGROUP BY a.abteilung_id, a.name\nHAVING COUNT(m.mitarbeiter_id) > 0\nORDER BY anzahl DESC;",
      "language": "sql",
      "options": [
        "Zeigt alle Abteilungen mit Mitarbeiteranzahl, sortiert nach Anzahl absteigend",
        "Zeigt nur Abteilungen mit mindestens einem Mitarbeiter, sortiert nach Anzahl absteigend",
        "Zeigt alle Mitarbeiter gruppiert nach Abteilung",
        "Gibt einen Fehler aus"
      ],
      "correctAnswer": "Zeigt nur Abteilungen mit mindestens einem Mitarbeiter, sortiert nach Anzahl absteigend",
      "explanation": "LEFT JOIN würde alle Abteilungen zeigen, aber HAVING COUNT(m.mitarbeiter_id) > 0 filtert Abteilungen ohne Mitarbeiter heraus. ORDER BY anzahl DESC sortiert absteigend.",
      "points": 3,
      "category": "DQL"
    }
  ],
  "tags": ["SQL", "DDL", "DML", "DQL", "IHK", "Prüfung", "Datenbank"],
  "lastUpdated": "2025-01-10T00:00:00Z"
}
