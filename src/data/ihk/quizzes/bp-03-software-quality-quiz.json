{
  "id": "bp-03-software-quality-quiz",
  "moduleId": "bp-03-software-quality",
  "title": "Softwarequalität und Clean Code Quiz",
  "description": "Teste dein Wissen über Softwarequalität, Clean Code, SOLID-Prinzipien, Code-Reviews und Refactoring",
  "category": "BP-03",
  "difficulty": "intermediate",
  "examRelevance": "high",
  "timeLimit": 25,
  "passingScore": 70,
  "questions": [
    {
      "id": "q1",
      "type": "single-choice",
      "question": "Was beschreibt die ISO 25010 Norm?",
      "options": [
        "Qualitätsmerkmale für Softwareprodukte und -systeme",
        "Sicherheitsstandards für Webanwendungen",
        "Projektmanagement-Methoden",
        "Datenbankdesign-Richtlinien"
      ],
      "correctAnswer": "Qualitätsmerkmale für Softwareprodukte und -systeme",
      "explanation": "ISO 25010 definiert acht Hauptqualitätsmerkmale für Software: Funktionale Eignung, Leistungseffizienz, Kompatibilität, Benutzbarkeit, Zuverlässigkeit, Sicherheit, Wartbarkeit und Übertragbarkeit. Diese Norm ist der Nachfolger von ISO 9126.",
      "points": 1,
      "category": "Grundlagen"
    },
    {
      "id": "q2",
      "type": "multiple-choice",
      "question": "Welche gehören zu den acht Hauptqualitätsmerkmalen der ISO 25010? (Mehrere Antworten möglich)",
      "options": [
        "Wartbarkeit (Maintainability)",
        "Zuverlässigkeit (Reliability)",
        "Profitabilität (Profitability)",
        "Skalierbarkeit (Scalability)"
      ],
      "correctAnswer": [
        "Wartbarkeit (Maintainability)",
        "Zuverlässigkeit (Reliability)"
      ],
      "explanation": "Wartbarkeit und Zuverlässigkeit sind zwei der acht Hauptqualitätsmerkmale der ISO 25010. Profitabilität ist ein Geschäftsziel, kein Qualitätsmerkmal. Skalierbarkeit ist ein Aspekt der Leistungseffizienz, aber kein eigenständiges Hauptmerkmal.",
      "points": 2,
      "category": "ISO 25010"
    },
    {
      "id": "q3",
      "type": "single-choice",
      "question": "Was bedeutet das 'S' in den SOLID-Prinzipien?",
      "options": [
        "Single Responsibility Principle",
        "Software Reliability Principle",
        "Secure Implementation Principle",
        "System Scalability Principle"
      ],
      "correctAnswer": "Single Responsibility Principle",
      "explanation": "Das 'S' in SOLID steht für Single Responsibility Principle (Prinzip der eindeutigen Verantwortlichkeit). Es besagt, dass eine Klasse nur eine einzige Verantwortlichkeit haben sollte und nur einen Grund zur Änderung haben darf.",
      "points": 1,
      "category": "SOLID"
    },
    {
      "id": "q4",
      "type": "single-choice",
      "question": "Was besagt das Open/Closed Principle (OCP)?",
      "options": [
        "Software sollte offen für Erweiterung, aber geschlossen für Modifikation sein",
        "Klassen sollten öffentliche und private Methoden haben",
        "Code sollte Open Source sein",
        "Datenbanken sollten offen für Lesen, geschlossen für Schreiben sein"
      ],
      "correctAnswer": "Software sollte offen für Erweiterung, aber geschlossen für Modifikation sein",
      "explanation": "Das Open/Closed Principle besagt, dass Software-Entitäten offen für Erweiterungen, aber geschlossen für Modifikationen sein sollten. Man sollte das Verhalten erweitern können, ohne bestehenden Code zu ändern, z.B. durch Vererbung oder Interfaces.",
      "points": 1,
      "category": "SOLID"
    },
    {
      "id": "q5",
      "type": "single-choice",
      "question": "Was ist Technical Debt (Technische Schulden)?",
      "options": [
        "Kosten für zukünftige Wartung durch suboptimale Implementierung",
        "Finanzielle Schulden für Software-Lizenzen",
        "Zeitverzögerung bei der Projektabgabe",
        "Fehlende Dokumentation im Projekt"
      ],
      "correctAnswer": "Kosten für zukünftige Wartung durch suboptimale Implementierung",
      "explanation": "Technical Debt bezeichnet die impliziten Kosten zusätzlicher Arbeit, die durch schnelle, suboptimale Lösungen entstehen. Wie finanzielle Schulden müssen technische Schulden mit 'Zinsen' (erhöhter Wartungsaufwand) zurückgezahlt werden. Bewusste technische Schulden können sinnvoll sein, sollten aber dokumentiert und geplant abgebaut werden.",
      "points": 1,
      "category": "Code-Qualität"
    },
    {
      "id": "q6",
      "type": "multiple-choice",
      "question": "Welche Aussagen über Clean Code sind korrekt? (Mehrere Antworten möglich)",
      "options": [
        "Code sollte selbsterklärend sein",
        "Funktionen sollten nur eine Aufgabe erfüllen",
        "Kommentare sind immer besser als verständlicher Code",
        "Lange Funktionsnamen sind immer schlecht"
      ],
      "correctAnswer": [
        "Code sollte selbsterklärend sein",
        "Funktionen sollten nur eine Aufgabe erfüllen"
      ],
      "explanation": "Clean Code sollte selbsterklärend sein und Funktionen sollten nur eine Aufgabe erfüllen (Single Responsibility). Guter Code braucht weniger Kommentare, da er durch aussagekräftige Namen selbsterklärend ist. Lange, aber beschreibende Funktionsnamen sind besser als kurze, unklare Namen.",
      "points": 2,
      "category": "Clean Code"
    },
    {
      "id": "q7",
      "type": "single-choice",
      "question": "Was ist der Hauptzweck von Code-Reviews?",
      "options": [
        "Qualitätssicherung und Wissensaustausch im Team",
        "Kontrolle der Arbeitszeit von Entwicklern",
        "Automatische Fehlererkennung",
        "Erstellung von Dokumentation"
      ],
      "correctAnswer": "Qualitätssicherung und Wissensaustausch im Team",
      "explanation": "Code-Reviews dienen der Qualitätssicherung (Fehler finden, Best Practices durchsetzen) und dem Wissensaustausch im Team. Sie fördern gemeinsames Code-Verständnis, verbessern die Code-Qualität und helfen, Fehler früh zu erkennen. Sie sind kein Kontrollmechanismus für Entwickler.",
      "points": 1,
      "category": "Code-Reviews"
    },
    {
      "id": "q8",
      "type": "single-choice",
      "question": "Was bedeutet Refactoring?",
      "options": [
        "Umstrukturierung von Code ohne Änderung des externen Verhaltens",
        "Hinzufügen neuer Features",
        "Behebung von Bugs",
        "Löschen von altem Code"
      ],
      "correctAnswer": "Umstrukturierung von Code ohne Änderung des externen Verhaltens",
      "explanation": "Refactoring ist die Umstrukturierung von Code zur Verbesserung der internen Struktur, ohne das externe Verhalten zu ändern. Ziele sind bessere Lesbarkeit, Wartbarkeit und Performance. Es unterscheidet sich von Bug-Fixes (Verhaltensänderung) und neuen Features (Funktionserweiterung).",
      "points": 1,
      "category": "Refactoring"
    },
    {
      "id": "q9",
      "type": "code",
      "question": "Welches SOLID-Prinzip wird in diesem Code verletzt?",
      "code": "class User {\n  saveToDatabase() { /* DB-Logik */ }\n  sendEmail() { /* Email-Logik */ }\n  validateData() { /* Validierung */ }\n  generateReport() { /* Report */ }\n}",
      "language": "javascript",
      "options": [
        "Single Responsibility Principle",
        "Open/Closed Principle",
        "Liskov Substitution Principle",
        "Dependency Inversion Principle"
      ],
      "correctAnswer": "Single Responsibility Principle",
      "explanation": "Die User-Klasse verletzt das Single Responsibility Principle, da sie mehrere Verantwortlichkeiten hat: Datenbankzugriff, Email-Versand, Validierung und Report-Generierung. Jede dieser Aufgaben sollte in eine separate Klasse ausgelagert werden, sodass jede Klasse nur einen Grund zur Änderung hat.",
      "points": 2,
      "category": "SOLID"
    },
    {
      "id": "q10",
      "type": "single-choice",
      "question": "Was ist ein Code Smell?",
      "options": [
        "Ein Hinweis auf potenzielle Probleme im Code",
        "Ein Syntaxfehler",
        "Ein Sicherheitsleck",
        "Eine veraltete Bibliothek"
      ],
      "correctAnswer": "Ein Hinweis auf potenzielle Probleme im Code",
      "explanation": "Ein Code Smell ist ein Symptom im Code, das auf tieferliegende Probleme hinweist. Beispiele: Duplizierter Code, zu lange Methoden, zu viele Parameter, unklare Namen. Code Smells sind keine Fehler, aber Indikatoren für schlechtes Design, das refaktoriert werden sollte.",
      "points": 1,
      "category": "Code-Qualität"
    },
    {
      "id": "q11",
      "type": "multiple-choice",
      "question": "Welche sind typische Code Smells? (Mehrere Antworten möglich)",
      "options": [
        "Duplizierter Code (Duplicated Code)",
        "Lange Methoden (Long Method)",
        "Verwendung von Kommentaren",
        "Zu viele Parameter (Long Parameter List)"
      ],
      "correctAnswer": [
        "Duplizierter Code (Duplicated Code)",
        "Lange Methoden (Long Method)",
        "Zu viele Parameter (Long Parameter List)"
      ],
      "explanation": "Duplizierter Code, lange Methoden und zu viele Parameter sind klassische Code Smells. Kommentare an sich sind kein Code Smell, aber übermäßige Kommentare können darauf hinweisen, dass der Code nicht selbsterklärend genug ist. Das DRY-Prinzip (Don't Repeat Yourself) hilft gegen duplizierten Code.",
      "points": 2,
      "category": "Code-Qualität"
    },
    {
      "id": "q12",
      "type": "single-choice",
      "question": "Was bedeutet das DRY-Prinzip?",
      "options": [
        "Don't Repeat Yourself - Vermeide Code-Duplikation",
        "Do Review Yearly - Jährliche Code-Reviews",
        "Debug Regularly Yourself - Regelmäßiges Debugging",
        "Document Requirements Yearly - Jährliche Anforderungsdokumentation"
      ],
      "correctAnswer": "Don't Repeat Yourself - Vermeide Code-Duplikation",
      "explanation": "DRY (Don't Repeat Yourself) besagt, dass jedes Wissen im System eine eindeutige, autoritative Repräsentation haben sollte. Code-Duplikation führt zu Wartungsproblemen, da Änderungen an mehreren Stellen vorgenommen werden müssen. Stattdessen sollte gemeinsame Logik in wiederverwendbare Funktionen oder Klassen ausgelagert werden.",
      "points": 1,
      "category": "Clean Code"
    },
    {
      "id": "q13",
      "type": "single-choice",
      "question": "Was ist das Liskov Substitution Principle (LSP)?",
      "options": [
        "Objekte einer Oberklasse sollten durch Objekte ihrer Unterklassen ersetzbar sein",
        "Klassen sollten nur von einer Oberklasse erben",
        "Unterklassen sollten immer größer als Oberklassen sein",
        "Vererbung sollte vermieden werden"
      ],
      "correctAnswer": "Objekte einer Oberklasse sollten durch Objekte ihrer Unterklassen ersetzbar sein",
      "explanation": "Das Liskov Substitution Principle besagt, dass Objekte einer Oberklasse durch Objekte ihrer Unterklassen ersetzbar sein sollten, ohne die Korrektheit des Programms zu beeinträchtigen. Unterklassen müssen den Vertrag der Oberklasse einhalten und dürfen keine stärkeren Vorbedingungen oder schwächeren Nachbedingungen haben.",
      "points": 1,
      "category": "SOLID"
    },
    {
      "id": "q14",
      "type": "code",
      "question": "Was ist das Problem mit diesem Code aus Clean-Code-Perspektive?",
      "code": "function calc(a, b, c) {\n  if (c == 1) return a + b;\n  if (c == 2) return a - b;\n  if (c == 3) return a * b;\n  if (c == 4) return a / b;\n}",
      "language": "javascript",
      "options": [
        "Unklare Parameternamen und Magic Numbers",
        "Zu viele if-Statements",
        "Fehlende Fehlerbehandlung",
        "Alle genannten Punkte"
      ],
      "correctAnswer": "Alle genannten Punkte",
      "explanation": "Der Code hat mehrere Probleme: 1) Unklare Namen (a, b, c sagen nichts aus), 2) Magic Numbers (1, 2, 3, 4 ohne Bedeutung), 3) Fehlende Fehlerbehandlung für ungültige c-Werte. Besser wären aussagekräftige Namen, Enums oder Konstanten für Operationen, und ein default-Fall oder Fehlerbehandlung.",
      "points": 2,
      "category": "Clean Code"
    },
    {
      "id": "q15",
      "type": "single-choice",
      "question": "Was ist das Interface Segregation Principle (ISP)?",
      "options": [
        "Clients sollten nicht von Interfaces abhängen, die sie nicht nutzen",
        "Interfaces sollten immer klein sein",
        "Jede Klasse sollte nur ein Interface implementieren",
        "Interfaces sollten keine Methoden haben"
      ],
      "correctAnswer": "Clients sollten nicht von Interfaces abhängen, die sie nicht nutzen",
      "explanation": "Das Interface Segregation Principle besagt, dass Clients nicht gezwungen werden sollten, von Interfaces abzuhängen, die sie nicht nutzen. Besser sind mehrere spezifische Interfaces als ein großes, allgemeines Interface. Dies verhindert, dass Klassen Methoden implementieren müssen, die sie nicht benötigen.",
      "points": 1,
      "category": "SOLID"
    },
    {
      "id": "q16",
      "type": "single-choice",
      "question": "Was ist das Dependency Inversion Principle (DIP)?",
      "options": [
        "High-Level-Module sollten nicht von Low-Level-Modulen abhängen, beide sollten von Abstraktionen abhängen",
        "Abhängigkeiten sollten immer vermieden werden",
        "Low-Level-Module sollten High-Level-Module steuern",
        "Alle Klassen sollten voneinander abhängig sein"
      ],
      "correctAnswer": "High-Level-Module sollten nicht von Low-Level-Modulen abhängen, beide sollten von Abstraktionen abhängen",
      "explanation": "Das Dependency Inversion Principle besagt, dass High-Level-Module nicht von Low-Level-Modulen abhängen sollten. Beide sollten von Abstraktionen (Interfaces) abhängen. Dies ermöglicht Flexibilität und Testbarkeit durch Dependency Injection und macht den Code weniger gekoppelt.",
      "points": 1,
      "category": "SOLID"
    },
    {
      "id": "q17",
      "type": "multiple-choice",
      "question": "Welche Metriken werden häufig zur Messung der Code-Qualität verwendet? (Mehrere Antworten möglich)",
      "options": [
        "Code Coverage (Testabdeckung)",
        "Zyklomatische Komplexität",
        "Anzahl der Codezeilen",
        "Anzahl der Entwickler"
      ],
      "correctAnswer": [
        "Code Coverage (Testabdeckung)",
        "Zyklomatische Komplexität"
      ],
      "explanation": "Code Coverage (Prozentsatz des getesteten Codes) und zyklomatische Komplexität (Anzahl unabhängiger Pfade durch den Code) sind wichtige Qualitätsmetriken. Die reine Anzahl der Codezeilen ist kein guter Qualitätsindikator (weniger Code kann besser sein). Die Anzahl der Entwickler ist keine Code-Qualitätsmetrik.",
      "points": 2,
      "category": "Code-Qualität"
    },
    {
      "id": "q18",
      "type": "single-choice",
      "question": "Was ist der Hauptvorteil von Pair Programming für die Code-Qualität?",
      "options": [
        "Kontinuierliche Code-Review und Wissensaustausch",
        "Doppelte Entwicklungsgeschwindigkeit",
        "Weniger Meetings erforderlich",
        "Automatische Fehlererkennung"
      ],
      "correctAnswer": "Kontinuierliche Code-Review und Wissensaustausch",
      "explanation": "Pair Programming bietet kontinuierliche Code-Review (ein Entwickler schreibt, der andere überprüft) und fördert Wissensaustausch. Dies führt zu höherer Code-Qualität, weniger Bugs und besserem gemeinsamen Verständnis. Die Entwicklungsgeschwindigkeit ist nicht doppelt so hoch, aber die Qualität ist oft besser.",
      "points": 1,
      "category": "Code-Reviews"
    },
    {
      "id": "q19",
      "type": "single-choice",
      "question": "Was ist der Zweck von Static Code Analysis Tools?",
      "options": [
        "Automatische Erkennung von Code-Problemen ohne Ausführung",
        "Ausführung von Unit-Tests",
        "Erstellung von Dokumentation",
        "Deployment von Anwendungen"
      ],
      "correctAnswer": "Automatische Erkennung von Code-Problemen ohne Ausführung",
      "explanation": "Static Code Analysis Tools (z.B. SonarQube, ESLint, PMD) analysieren den Quellcode ohne ihn auszuführen. Sie erkennen potenzielle Bugs, Code Smells, Sicherheitslücken, Stil-Verstöße und Komplexitätsprobleme. Sie ergänzen Tests, ersetzen sie aber nicht.",
      "points": 1,
      "category": "Code-Qualität"
    },
    {
      "id": "q20",
      "type": "multiple-choice",
      "question": "Welche Faktoren beeinflussen die Wartbarkeit von Software? (Mehrere Antworten möglich)",
      "options": [
        "Code-Lesbarkeit und Verständlichkeit",
        "Modularer Aufbau und lose Kopplung",
        "Umfangreiche Dokumentation",
        "Anzahl der verwendeten Programmiersprachen"
      ],
      "correctAnswer": [
        "Code-Lesbarkeit und Verständlichkeit",
        "Modularer Aufbau und lose Kopplung",
        "Umfangreiche Dokumentation"
      ],
      "explanation": "Wartbarkeit wird durch lesbare, verständliche Code, modularen Aufbau mit loser Kopplung und gute Dokumentation verbessert. Die Anzahl der Programmiersprachen kann die Wartbarkeit erschweren, ist aber nicht per se ein Qualitätsfaktor. Wichtiger sind klare Strukturen, Tests und selbsterklärender Code.",
      "points": 2,
      "category": "Wartbarkeit"
    }
  ],
  "tags": [
    "Qualität",
    "ISO 25010",
    "Clean Code",
    "SOLID",
    "Refactoring",
    "Code-Reviews",
    "Technical Debt"
  ],
  "lastUpdated": "2025-01-10"
}